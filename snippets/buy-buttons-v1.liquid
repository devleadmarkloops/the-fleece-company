{% comment %}
  Renders product buy-buttons.
  Accepts:
  - product: {Object} product object.
  - block: {Object} passing the block information.
  - product_form_id: {String} product form id.
  - section_id: {String} id of section to which this snippet belongs.
  - show_pickup_availability:: {Boolean} for the pickup availability. If true the pickup availability is rendered, false - not rendered (optional).
  Usage:
  {% render 'buy-buttons', block: block, product: product, product_form_id: product_form_id, show_pickup_availability: true %}
{% endcomment %}
<div {{ block.shopify_attributes }}>
{%- if product != blank -%}
  {%- liquid
    assign gift_card_recipient_feature_active = false
    if block.settings.show_gift_card_recipient and product.gift_card?
      assign gift_card_recipient_feature_active = true
    endif

    assign show_dynamic_checkout = false
    if block.settings.show_dynamic_checkout and gift_card_recipient_feature_active == false
      assign show_dynamic_checkout = true
    endif
  -%}
  <product-form 
    class="product-form"
    data-hide-errors="{{ gift_card_recipient_feature_active }}"
    data-section-id="{{ section.id }}"
  >
    <div class="product-form__error-message-wrapper" role="alert" hidden>
      {%- render 'icon', icon: 'error-red' -%}
      <span class="product-form__error-message"></span>
    </div>
    
    {%- form 'product',
      product,
      id: product_form_id,
      class: 'form',
      novalidate: 'novalidate',
      data-type: 'add-to-cart-form'
    -%}
      <input
        type="hidden"
        name="id"
        value="{{ product.selected_or_first_available_variant.id }}"
        {% if product.selected_or_first_available_variant.available == false
          or quantity_rule_soldout
          or product.selected_or_first_available_variant == null
        %}
          disabled="disabled"
        {% endif %}
        class="product-variant-id"
      >
      {%- if gift_card_recipient_feature_active -%}
        {%- render 'gift-card-recipient-form', product: product, form: form, section: section -%}
      {%- endif -%}
      
      {%- comment -%} Monogram Feature {%- endcomment -%}
      {%- if block.settings.enable_monogram and block.settings.monogram_product != blank -%}
        {%- assign monogram_product = all_products[block.settings.monogram_product] -%}
        {%- if monogram_product != blank -%}
          {%- assign monogram_variant = monogram_product.selected_or_first_available_variant -%}
          {%- if monogram_variant.available -%}
            <div
              class="monogram-wrapper-{{ section.id }}"
              data-form-id="{{ product_form_id }}"
              data-section-id="{{ section.id }}"
              data-monogram-price="{{ monogram_variant.price }}"
            >
              <div class="monogram-box" id="monogram-box-{{ section.id }}" style="display: none;">
                <div class="monogram-total-price">
                  <strong>Mongramming: <span class="monogram-unit-price-display"> +{{ monogram_variant.price | money }} / monogram </span></strong>                  
                  <p class="monogram-processing-notice" style="margin: 5px 0 0 0; font-size: 14px;">Please note Monogrammed items take an additional 4-6 business days for processing.</p>
                </div>
                <div class="monogram-items-container" id="monogram-items-container-{{ section.id }}">
                  {%- comment -%} Monogram items will be dynamically generated here based on bundle selection {%- endcomment -%}
                </div>

                {%- comment -%} Template for single monogram item (hidden, used as template) {%- endcomment -%}
                <div id="monogram-item-template-{{ section.id }}" style="display: none !important;">
                  <div class="monogram-item" data-item-index="">
                    <div class="monogram-content-wrapper">
                      <div class="monogram-image-container monogram-image-container-item">
                        {%- comment -%} 
                          Monogram Images - Priority Order:
                          1. Variant-level metafields (custom.variant_monogram_images) - MOST ACCURATE
                          2. Product-level metafields (custom.monogram_images) - FALLBACK
                          3. Product featured image - FINAL FALLBACK
                        {%- endcomment -%}
                        {%- assign current_variant = product.selected_or_first_available_variant -%}
                        {%- assign variant_images = current_variant.metafields.custom.variant_monogram_images -%}
                        {%- assign product_images = product.metafields.custom.monogram_images -%}
                        
                        {%- if variant_images != blank and variant_images.value.size > 0 -%}
                          {%- comment -%} Use variant-specific images (BEST APPROACH) {%- endcomment -%}
                          {%- for img in variant_images.value -%}
                            <img
                              class="monogram-base-image"
                              data-variant-id="{{ current_variant.id }}"
                              data-image-source="variant"
                              src="{{ img | image_url: width: 600 }}"
                              alt="{{ product.title }} - {{ current_variant.title }}"
                              loading="lazy"
                              width="600"
                              height="600"
                              style="display: none;"
                            >
                          {%- endfor -%}
                        {%- elsif product_images != blank and product_images.value.size > 0 -%}
                          {%- comment -%} Product-level images - all hidden initially, JS will show matching color {%- endcomment -%}
                          {%- assign monogram_colors = product.metafields.custom.monogram_colors1.value -%}
                          {%- for img in product_images.value -%}
                            {%- assign color_index = forloop.index0 -%}
                            {%- if monogram_colors[color_index] != blank -%}
                              {%- assign image_color = monogram_colors[color_index] -%}
                            {%- else -%}
                              {%- assign image_color = 'default' -%}
                            {%- endif -%}
                            <img
                              class="monogram-base-image"
                              data-color="{{ image_color | escape }}"
                              data-color-index="{{ color_index }}"
                              data-image-source="product"
                              src="{{ img | image_url: width: 600 }}"
                              alt="{{ product.title }} - {{ image_color }}"
                              loading="lazy"
                              width="600"
                              height="600"
                              style="display: none;"
                            >
                          {%- endfor -%}
                        {%- else -%}
                          {%- comment -%} Final fallback - only shown if no metafield images exist {%- endcomment -%}
                          <img
                            class="monogram-base-image"
                            data-color="default"
                            data-image-source="fallback"
                            src="{{ product.featured_image | image_url: width: 600 }}"
                            alt="{{ product.title }}"
                            loading="lazy"
                            width="600"
                            height="600"
                            style="display: none;"
                          >
                        {%- endif -%}
                        <span class="monogram-preview-text monogram-preview-text-item"></span>
                      </div>

                      <div class="monogram-options-panel">
                        <div class="monogram-item-header" style="display: flex; align-items: center; margin-bottom: 15px;">
                          <h4 class="monogram-item-title">Monogram <span class="monogram-item-number">1</span></h4>
                          <span class="monogram-added-badge" style="display: none;">Added</span>
                        </div>

                        <label class="monogram-label-item">Font Style</label>
                        <select class="monogram-style-select monogram-style-select-item">
                          {%- if shop.metaobjects.monogram_fonts.values != blank -%}
                            {%- for font in shop.metaobjects.monogram_fonts.values -%}
                              {%- assign font_display_name = font.font_name.value -%}
                              {%- if font_display_name == 'Playfair Display' -%}{%- assign font_display_name = 'Classic Serif' -%}{%- elsif font_display_name == 'Pinyon Script' -%}{%- assign font_display_name = 'Elegant Script' -%}{%- endif -%}
                              <option value="{{ font.font_name.value }}" data-url="{{ font.font_url1.value }}" {% if font_display_name == 'Classic Serif' %}selected{% endif %}>
                                {{ font_display_name }}
                              </option>
                            {%- endfor -%}
                          {%- endif -%}
                        </select>

                        <label class="monogram-label-item">Text Color</label>
                        <select class="monogram-color-select monogram-color-select-item">
                          <option value="Black" selected>Black</option>
                          <option value="White">White</option>
                        </select>

                        <label class="monogram-label-item">Monogram Text</label>
                        <input
                          type="text"
                          class="monogram-text-input monogram-text-input-item"
                          name="monogram_text"
                          maxlength="10"
                          placeholder="Enter text (max 10 characters)"
                        >
                      </div>
                    </div>
                  </div>
                </div>
                <div class="monogramTotal" id="monogram-total-price-{{ section.id }}" style="display: none;">
                  <strong>Total: <span class="monogram-total-price-value"></span></strong>
                </div>
                <div class="pod-description-d5">
                  {% comment %} <p>Please note: If 'Match Piping' is the color selection, the color in the preview is a sample. Our team will select the color that best matches the piping or print during production.
                  Please double check your selections before submitting. Once submitted monogram orders cannot be changed or canceled. Items with Monogram are final sale and not eligible for a return.
                  </p> {% endcomment %}
                  <div class="pod-terms-box-d5">
                    <input type="checkbox" id="pod-terms-{{ section.id }}" class="pod-terms-checkbox-{{ section.id }}">
                    <label for="pod-terms-{{ section.id }}">I have double checked all of my information and understand monogram items are not eligible for return or exchange.</label>
                  </div>
                </div>
              </div>
              <button type="button" class="monogram-toggle-btn" id="monogram-toggle-{{ section.id }}">
                <div class="monogram-btn-content">
                  <span class="monogram-btn-text">Add Monogram</span>
                  <span class="monogram-btn-count" style="display: none;"></span>
                </div>
              </button>
            </div>
            {%- endif -%}
          {%- endif -%}
        {%- endif -%}
      
      <div class="product-form__buttons{% if product.quantity_price_breaks_configured? %} with--price-break{% endif %}">
        {%- liquid
          assign check_against_inventory = true
          if product.selected_or_first_available_variant.inventory_management != 'shopify' or product.selected_or_first_available_variant.inventory_policy == 'continue'
            assign check_against_inventory = false
          endif
          if product.selected_or_first_available_variant.quantity_rule.min > product.selected_or_first_available_variant.inventory_quantity and check_against_inventory
            assign quantity_rule_soldout = true
          endif
        -%}
        {%- if block.settings.show_quantity_selector -%}
          <div id="Quantity-Form-{{ section.id }}" class="product-form__quantity">
            {% comment %} TODO: enable theme-check once `item_count_for_variant` is accepted as valid filter {% endcomment %}
            {% # theme-check-disable %}
            {%- assign cart_qty = cart
              | item_count_for_variant: product.selected_or_first_available_variant.id
            -%}
            {% # theme-check-enable %}
            <label for="Quantity-{{ section_id }}" class="visually-hidden">
              {{ 'products.product.quantity.label' | t }}
              <span class="quantity__rules-cart{% if cart_qty == 0 %} hidden{% endif %}">
                {%- render 'loading-spinner' -%}
                <span
                  >(
                  {{- 'products.product.quantity.in_cart_html' | t: quantity: cart_qty -}}
                  )</span
                >
              </span>
            </label>

            <div class="price-per-item__container">
              <quantity-input class="quantity" data-url="{{ product.url }}" data-block="{{ block.id }}" data-section="{{ section_id }}">
                <button class="quantity__button" name="minus" type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.decrease' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon', icon: 'minus' %}
                </button>
                <input
                  class="quantity__input quantity__input-primary"
                  type="number"
                  name="quantity"
                  id="Quantity-{{ section_id }}"
                  data-cart-quantity="{{ cart_qty }}"
                  data-min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  {% if product.selected_or_first_available_variant.quantity_rule.max != null %}
                    data-max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                    max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                  {% endif %}
                  step="{{ product.selected_or_first_available_variant.quantity_rule.increment }}"
                  value="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  form="{{ product_form_id }}"
                >
                <button class="quantity__button" name="plus" type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.increase' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon', icon: 'plus' %}
                </button>
              </quantity-input>
              {%- liquid
                assign volume_pricing_array = product.selected_or_first_available_variant.quantity_price_breaks | sort: 'quantity' | reverse
                assign current_qty_for_volume_pricing = cart_qty | plus: product.selected_or_first_available_variant.quantity_rule.min
                if cart_qty > 0
                  assign current_qty_for_volume_pricing = cart_qty | plus: product.selected_or_first_available_variant.quantity_rule.increment
                endif
              -%}
              {%- if product.quantity_price_breaks_configured? -%}
                <price-per-item
                  id="Price-Per-Item-{{ section.id }}"
                  data-section-id="{{ section.id }}"
                  data-variant-id="{{ product.selected_or_first_available_variant.id }}"
                >
                  {%- if product.selected_or_first_available_variant.quantity_price_breaks.size > 0 -%}
                    {%- assign variant_price_compare = product.selected_or_first_available_variant.compare_at_price -%}
                    <div class="price-per-item">
                      {%- if variant_price_compare -%}
                        <dl class="price-per-item--current">
                          <dt class="visually-hidden">
                            {{ 'products.product.price.regular_price' | t }}
                          </dt>
                          <dd>
                            <s class="variant-item__old-price">
                              {{ variant_price_compare | money_with_currency }}
                            </s>
                          </dd>
                        </dl>
                      {%- endif -%}
                      {%- if current_qty_for_volume_pricing < volume_pricing_array.last.minimum_quantity -%}
                        {%- assign variant_price = product.selected_or_first_available_variant.price
                          | money_with_currency
                        -%}
                        <span class="price-per-item--current">
                          {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                        </span>
                      {%- else -%}
                        {%- for price_break in volume_pricing_array -%}
                          {%- if current_qty_for_volume_pricing >= price_break.minimum_quantity -%}
                            {%- assign price_break_price = price_break.price | money_with_currency -%}
                            <span class="price-per-item--current">
                              {{-
                                'products.product.volume_pricing.price_at_each'
                                | t: price: price_break_price
                              -}}
                            </span>
                            {%- break -%}
                          {%- endif -%}
                        {%- endfor -%}
                      {%- endif -%}
                    </div>
                  {%- else -%}
                    {%- assign variant_price = product.selected_or_first_available_variant.price
                      | money_with_currency
                    -%}
                    {%- assign variant_price_compare = product.selected_or_first_available_variant.compare_at_price -%}
                    <div class="price-per-item">
                      {%- if variant_price_compare -%}
                        <dl class="price-per-item--current">
                          <dt class="visually-hidden">
                            {{ 'products.product.price.regular_price' | t }}
                          </dt>
                          <dd>
                            <s class="variant-item__old-price">
                              {{ variant_price_compare | money_with_currency }}
                            </s>
                          </dd>
                          <dt class="visually-hidden">
                            {{ 'products.product.price.sale_price' | t }}
                          </dt>
                          <dd>
                            <span class="price-per-item--current">
                              {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                            </span>
                          </dd>
                        </dl>
                      {%- else -%}
                        <span class="price-per-item--current">
                          {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                        </span>
                      {%- endif -%}
                    </div>
                  {%- endif -%}
                </price-per-item>
              {%- endif -%}
            </div>
            <div class="quantity__rules caption" id="Quantity-Rules-{{ section.id }}">
              {%- if product.selected_or_first_available_variant.quantity_rule.increment > 1 -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.multiples_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.increment
                  -}}
                </span>
              {%- endif -%}
              {%- if product.selected_or_first_available_variant.quantity_rule.min > 1 -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.minimum_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.min
                  -}}
                </span>
              {%- endif -%}
              {%- if product.selected_or_first_available_variant.quantity_rule.max != null -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.maximum_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.max
                  -}}
                </span>
              {%- endif -%}
            </div>
            {%- if product.quantity_price_breaks_configured? -%}
              <volume-pricing class="parent-display" id="Volume-{{ section.id }}">
                {%- if product.selected_or_first_available_variant.quantity_price_breaks.size > 0 -%}
                  <span class="caption-large">{{ 'products.product.volume_pricing.title' | t }}</span>
                  <ul class="list-unstyled">
                    <li>
                      <span>{{ product.selected_or_first_available_variant.quantity_rule.min }}+</span>
                      {%- assign price = product.selected_or_first_available_variant.price
                        | money_with_currency
                      -%}
                      <span data-text="{{ 'products.product.volume_pricing.price_at_each' | t: price: variant_price }}">
                        {{- 'sections.quick_order_list.each' | t: money: price -}}
                      </span>
                    </li>
                    {%- for price_break in product.selected_or_first_available_variant.quantity_price_breaks -%}
                      {%- assign price_break_price = price_break.price | money_with_currency -%}
                      <li class="{%- if forloop.index >= 3 -%}show-more-item hidden{%- endif -%}">
                        <span>
                          {{- price_break.minimum_quantity -}}
                          <span aria-hidden="true">+</span></span
                        >
                        <span data-text="{{ 'products.product.volume_pricing.price_at_each' | t: price: price_break_price }}">
                          {{- 'sections.quick_order_list.each' | t: money: price_break_price -}}
                        </span>
                      </li>
                    {%- endfor -%}
                  </ul>
                  {%- if product.selected_or_first_available_variant.quantity_price_breaks.size >= 3 -%}
                    <vp-show-more-button>
                      <button
                        class="button-show-more link underlined-link"
                        id="Show-More-{{ section.id }}"
                        type="button"
                      >
                        <span class="label-show-more label-text"
                          ><span aria-hidden="true">+ </span>{{ 'products.facets.show_more' | t }}
                        </span>
                      </button>
                    </vp-show-more-button>
                  {%- endif -%}
                {%- endif -%}
              </volume-pricing>
            {%- endif -%}
          </div>
        {%- endif -%}
        <button
          id="ProductSubmitButton-{{ section_id }}"
          type="submit"
          name="add"
          class="product-form__submit button{% if show_dynamic_checkout %} button--secondary{% endif %} button--full-width"
          {%- if product.selected_or_first_available_variant.available == false or quantity_rule_soldout
            or product.selected_or_first_available_variant == null %} disabled="disabled"{% endif -%}
          {%- if product.template_suffix == 'pre-order' %} data-pre-order="true"{% endif -%}
        >
          <span>
            {%- if product.selected_or_first_available_variant == null -%}
              {{ 'products.product.unavailable' | t }}
            {%- elsif product.selected_or_first_available_variant.available == false or quantity_rule_soldout -%}
              {{ 'products.product.sold_out' | t }}
            {%- else -%}
              {%- liquid
                if product.template_suffix != 'pre-order'
                  echo 'products.product.add_to_cart' | t
                else
                  echo 'products.product.pre_order' | t
                endif
              -%}
              <span class="btn-price-separator"> — </span>
              <span class="btn-price">{{ product.selected_or_first_available_variant.price | money }}</span>
            {%- endif -%}
          </span>
        </button>
        {%- if show_dynamic_checkout -%}
          {{ form | payment_button }}
        {%- endif -%}
      </div>
    {%- endform -%}
  </product-form>
{%- else -%}
  <div class="product-form">
    <div class="product-form__buttons form">
      <button
        type="submit"
        name="add"
        class="product-form__submit button button--full-width button--primary"
        disabled
      >
        {{ 'products.product.sold_out' | t }}
      </button>
    </div>
  </div>
{%- endif -%}

{%- if show_pickup_availability -%}
  {{ 'component-pickup-availability.css' | asset_url | stylesheet_tag }}
  {%- assign pick_up_availabilities = product.selected_or_first_available_variant.store_availabilities | where: 'pick_up_enabled', true -%}
  <pickup-availability class="product__pickup-availabilities no-js-hidden"
    {% if product.selected_or_first_available_variant.available and pick_up_availabilities.size > 0 %} available{% endif %}
    data-root-url="{{ routes.root_url }}"
    data-variant-id="{{ product.selected_or_first_available_variant.id }}"
    data-has-only-default-variant="{{ product.has_only_default_variant }}"
  >
    <template>
      <pickup-availability-preview class="pickup-availability-preview">
        {% render 'icon', icon: 'unavailable' %}
        <div class="pickup-availability-info">
          <p class="caption-large">{{ 'products.product.pickup_availability.unavailable' | t }}</p>
          <button class="pickup-availability-button link link--underline">{{ 'products.product.pickup_availability.refresh' | t }}</button>
        </div>
      </pickup-availability-preview>
    </template>
  </pickup-availability>
  <script src="{{ 'pickup-availability.js' | asset_url }}" defer="defer"></script>
{%- endif -%}

{%- comment -%} Monogram Styles and Scripts {%- endcomment -%}
{%- if block.settings.enable_monogram and block.settings.monogram_product != blank -%}
  {%- assign monogram_product_check = all_products[block.settings.monogram_product] -%}
  {%- if monogram_product_check != blank -%}
    {%- assign monogram_variant_check = monogram_product_check.selected_or_first_available_variant -%}
    {%- if monogram_variant_check.available -%}
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Playfair+Display:wght@400&display=swap" rel="stylesheet">
      <style>
        .product-form__submit.monogram-disabled {
          pointer-events: none;
          opacity: 0.7;
        }
        .monogram-wrapper-{{ section.id }} {
          margin-bottom: 0;
        }
        .monogram-toggle-btn {
          width: 100%;
          padding: 12px 24px;
          background: transparent;
          border: 1px solid #000;
          color: #000;
          font-family: var(--font-body-family);
          font-weight: 600;
          font-size: 16px;
          cursor: pointer;
          text-transform: uppercase;
          letter-spacing: 1px;
          margin-bottom: 15px;
          border-radius:8px;
          transition: all 0.3s ease;
          position:relative;
          background:#f6f3ee;
          color:#000;
          display: flex;
          align-items: center;
          justify-content: center;
          min-height: 50px;
        }
        .monogram-btn-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          line-height: 1.2;
          width: 100%;
          z-index: 11;
        }
        .monogram-btn-count {
          font-size: 13px;
          font-weight: 400;
          margin-top: 5px;
          text-transform: none;
          letter-spacing: 0;
        }
        .monogram-toggle-btn:before {
          border: 1px solid #000;
          content: "";
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          width: calc(100% - 6px);
          height: calc(100% - 6px);
          border-radius:6px;
        }
        .monogram-total-price {
          margin-bottom: 20px;
          padding-bottom: 20px;
          border-bottom: 1px solid #eee;
          font-size: 16px;
        }
        .monogram-total-price strong {
          font-weight: 600;
        }
        .monogram-total-price-value {
          font-weight: 600;
        }
        .monogram-box {
          border: 1px solid #ddd;
          padding: 20px;
          margin-bottom: 20px;
          background: #fff;
        }
        .monogram-items-container {
          display: flex;
          flex-direction: column;
          gap: 30px;
        }
        .monogram-item {
          border-bottom: 1px solid #eee;
          padding-bottom: 30px;
        }
        .monogram-item:last-child {
          border-bottom: none;
          padding-bottom: 0;
        }
        .monogram-item-header {
          margin-bottom: 15px;
        }
        .monogram-item-title {
          font-size: 16px;
          font-weight: 600;
          margin: 0;
          text-transform: uppercase;
        }
        .monogram-added-badge {
          background: #000;
          color: #fff;
          font-size: 10px;
          padding: 2px 8px;
          border-radius: 12px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          font-weight: 700;
          margin-left: 10px;
          vertical-align: middle;
        }
        .monogram-content-wrapper {
          display: flex;
          gap: 30px;
          margin-bottom: 0;
        }
        .monogram-image-container {
          position: relative;
          flex: 0 0 300px;
          max-width: 300px;
          border: 1px solid #eee;
          background: #f9f9f9;
          min-height: 300px;
          cursor: crosshair;
        }
        .monogram-base-image {
          max-width: 100%;
          width: 100%;
          height: auto;
          /* Note: display is controlled via inline styles for visibility toggling */
        }
        .monogram-preview-text {
          position: absolute;
          top: 78%;
          left: 64%;
          transform: translate(-50%, -50%);
          font-size: 16px;
          font-weight: 400;
          user-select: none;
          white-space: nowrap;
          cursor: move;
          z-index: 10;
          color: #000000;
          display: block;
          min-width: 1px;
          min-height: 1px;
        }
        .monogram-options-panel {
          flex: 1;
        }
        .monogram-options-panel label {
          display: block;
          margin-top: 15px;
          margin-bottom: 5px;
          font-weight: 600;
          font-size: 14px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        .monogram-options-panel label:first-child {
          margin-top: 0;
        }
        .monogram-style-select,
        .monogram-color-select,
        .monogram-text-input {
          width: 100%;
          padding: 10px;
          border: 1px solid #ccc;
          font-size: 14px;
          margin-bottom: 5px;
        }
        .pod-description-d5 input {
          all: unset;
          border: 1px solid #ddd;
          border-radius: 8px;
          min-width: 27px;
          max-width: 27px;
          height: 27px;
          background: #fff;
        }
        .pod-description-d5 label {
          line-height: 1.3;
          cursor: pointer;
        }
        .pod-description-d5 input:checked {
          background: #111;
        }
        .pod-description-d5 input:checked:after {
          content: '✓';
          width: 27px;
          height: 27px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: #fff;
          font-weight: 700;
        }
        .pod-terms-box-d5 {
          display: flex;
          align-items: unset;
          gap: 15px;
          cursor: pointer;
          margin-bottom: 20px;
          margin-top: 10px;
        }
        .monogramTotal{
          margin-top:10px;
        }
        @media (max-width: 767px) {
          .monogram-content-wrapper {
            flex-direction: column;
          }
          .monogram-image-container {
            flex: 1;
            max-width: 100%;
            min-height: 250px;
          }
          .monogram-text-input {
            font-size: 16px;
          }
        }
      </style>

      <script>
      (function() {
        'use strict';
        const sectionId = '{{ section.id }}';
        const formId = '{{ product_form_id }}';
        const monogramProductId = {{ monogram_variant_check.id }};
        const mainProductId = {{ product.selected_or_first_available_variant.id }};
        
        document.addEventListener('DOMContentLoaded', function() {
          const wrapper = document.querySelector('.monogram-wrapper-{{ section.id }}');
          if (!wrapper) return;
          
          const toggleBtn = document.getElementById('monogram-toggle-{{ section.id }}');
          const monogramBox = document.getElementById('monogram-box-{{ section.id }}');
          const monogramItemsContainer = document.getElementById('monogram-items-container-{{ section.id }}');
          const monogramItemTemplate = document.getElementById('monogram-item-template-{{ section.id }}');
          const checkboxTerms = document.getElementById('pod-terms-{{ section.id }}');
          const processingNotice = wrapper.querySelector('.monogram-processing-notice-wrapper');
          // Get ATC button with fallback selectors
          const atcButton = document.querySelector('#ProductSubmitButton-{{ section_id }}') || 
                           document.querySelector('#ProductSubmitButton-{{ section.id }}') ||
                           wrapper?.closest('product-form')?.querySelector('button[type="submit"][name="add"]') ||
                           document.querySelector('button[type="submit"][name="add"]');
          const productFormElement = wrapper.closest('product-form');
          
          // Debug: Check if elements exist
          if (!toggleBtn) {
            console.error('[Monogram] Toggle button not found:', 'monogram-toggle-{{ section.id }}');
          }
          if (!monogramBox) {
            console.error('[Monogram] Monogram box not found:', 'monogram-box-{{ section.id }}');
          }

          let monogramItemsData = [];
          let currentBundleItemCount = 1;
          let isMonogramBoxOpen = false;
          // Base price in cents (from original currency, will be converted dynamically)
          const monogramBasePrice = {{ monogram_variant_check.price }};
          
          // Get current monogram price in current currency
          function getMonogramUnitPrice() {
            // Try to get updated price from data attribute (updated by currency switcher)
            if (wrapper) {
              const dataPrice = wrapper.getAttribute('data-monogram-price');
              if (dataPrice) {
                const price = parseInt(dataPrice);
                if (!isNaN(price) && price > 0) {
                  return price;
                }
              }
            }
            // Fallback to base price
            return monogramBasePrice;
          }
          
          // Format money using current currency settings
          function formatMoney(cents) {
            // Use theme's currency formatter with current currency settings
            if (typeof theme !== 'undefined' && theme.Currency && theme.Currency.formatMoney) {
              const moneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat 
                ? theme.shopSettings.moneyFormat 
                : '{{ shop.money_format | json }}';
              return theme.Currency.formatMoney(cents, moneyFormat);
            }
            // Fallback to Shopify's formatMoney
            if (typeof Shopify !== 'undefined' && Shopify.formatMoney) {
              const moneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat 
                ? theme.shopSettings.moneyFormat 
                : '{{ shop.money_format | json }}';
              return Shopify.formatMoney(cents, moneyFormat);
            }
            // Final fallback
            const dollars = (cents / 100).toFixed(2);
            return '$' + dollars;
          }
          
          // Check if at least one monogram text field is filled
          function hasAnyMonogramText() {
            if (!monogramBox || monogramBox.style.display === 'none') {
              return false;
            }
            for (let i = 0; i < monogramItemsData.length; i++) {
              const itemData = monogramItemsData[i];
              if (itemData.textInput && itemData.textInput.value.trim()) {
                return true;
              }
            }
            return false;
          }
          
          // Update button disable state
          function updateATCButtonState() {
            // Robust button finding with multiple fallbacks
            const sectionIdVal = '{{ section.id }}';
            const atcButtonCurrent = document.getElementById('ProductSubmitButton-{{ section_id }}') || 
                             document.getElementById('ProductSubmitButton-' + sectionIdVal) ||
                             document.querySelector('#ProductSubmitButton-' + sectionIdVal) ||
                             wrapper?.closest('product-form')?.querySelector('button[type="submit"][name="add"]') ||
                             document.querySelector('button[type="submit"][name="add"]');

            if (!atcButtonCurrent) return;
            
            const checkboxChecked = checkboxTerms && checkboxTerms.checked;
            const textCount = countMonogramsWithText();
            const hasText = textCount > 0;
            
            // Should we disable strictly for monogram reasons?
            // Only disable if user HAS entered text but HAS NOT checked the terms.
            const shouldDisable = hasText && !checkboxChecked;
            
            if (shouldDisable) {
              atcButtonCurrent.classList.add('monogram-disabled');
              atcButtonCurrent.disabled = true;
            } else {
              atcButtonCurrent.classList.remove('monogram-disabled');
              
              // Enable the button IF it's not actually sold out
              const btnText = atcButtonCurrent.textContent.toLowerCase();
              const isSoldOut = atcButtonCurrent.hasAttribute('data-unavailable') && atcButtonCurrent.getAttribute('data-unavailable') === 'true';
              const soldOutByText = btnText.includes('sold_out') || btnText.includes('sold out') || btnText.includes('unavailable');
              
              if (!isSoldOut && !soldOutByText) {
                atcButtonCurrent.disabled = false;
              }
            }
          }

          // Small delay on initial load to ensure we override theme defaults
          setTimeout(updateATCButtonState, 500);

          if (checkboxTerms) {
            checkboxTerms.addEventListener('change', updateATCButtonState);
          }

          let loadedFonts = {};
          const btnTextSpan = toggleBtn ? toggleBtn.querySelector('.monogram-btn-text') : null;
          const btnCountSpan = toggleBtn ? toggleBtn.querySelector('.monogram-btn-count') : null;
          const totalPriceDisplay = document.getElementById('monogram-total-price-{{ section.id }}');
          const totalPriceValue = totalPriceDisplay ? totalPriceDisplay.querySelector('.monogram-total-price-value') : null;
          
          // Count monograms with text (strictly trimmed)
          function countMonogramsWithText() {
            let count = 0;
            if (!monogramItemsData) return 0;
            monogramItemsData.forEach(function(itemData) {
              if (itemData && itemData.textInput && itemData.textInput.value.trim().length > 0) {
                count++;
              }
            });
            return count;
          }
          
          // Update button text
          function updateMonogramButton() {
            if (!toggleBtn || !btnTextSpan) return;
            
            const count = countMonogramsWithText();
            const btnCountSpan = toggleBtn.querySelector('.monogram-btn-count');
            
            if (isMonogramBoxOpen) {
              btnTextSpan.textContent = 'Remove Monogram';
              if (btnCountSpan && count > 0) {
                btnCountSpan.textContent = count + ' added';
                btnCountSpan.style.display = 'block';
              } else if (btnCountSpan) {
                btnCountSpan.style.display = 'none';
              }
            } else {
              if (count > 0) {
                btnTextSpan.textContent = 'Remove Monogram';
                if (btnCountSpan) {
                  btnCountSpan.textContent = count + ' added';
                  btnCountSpan.style.display = 'block';
                }
              } else {
                btnTextSpan.textContent = 'Add Monogram';
                if (btnCountSpan) {
                  btnCountSpan.style.display = 'none';
                }
              }
            }
          }
          
          // Update total price and unit price display
          function updateMonogramTotalPrice() {
            if (!totalPriceDisplay || !totalPriceValue) return;
            
            // Update the unit price display at the top as well
            const unitPriceSpan = wrapper.querySelector('.monogram-unit-price-display');
            const monogramUnitPrice = getMonogramUnitPrice();
            if (unitPriceSpan) {
              unitPriceSpan.textContent = ' +' + formatMoney(monogramUnitPrice) + ' / monogram';
            }
            
            if (isMonogramBoxOpen) {
              const textFilledCount = countMonogramsWithText();
              const displayCount = Math.max(0, textFilledCount);
              
              if (displayCount > 0) {
                const totalPrice = monogramUnitPrice * displayCount;
                totalPriceValue.textContent = formatMoney(totalPrice) + ' (' + displayCount + ' monogram' + (displayCount > 1 ? 's' : '') + ')';
                totalPriceDisplay.style.display = 'block';
              } else {
                totalPriceDisplay.style.display = 'none';
              }
            } else {
              totalPriceDisplay.style.display = 'none';
            }
          }
          
          // Detect bundle selection
          function isBundleSelected() {
            return !!document.querySelector('.kaching-bundles__bar--selected');
          }
          
          function getSelectedBundleItemCount() {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return 1;
            
            // Method 1: Count variant selector wrappers (each item has color/size options)
            const variantSelectors = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (variantSelectors.length > 0) {
              console.log('[Monogram] Bundle item count from variant wrappers:', variantSelectors.length);
              return variantSelectors.length;
            }
            
            // Method 2: Try to get count from bundle title/name (e.g., "Buy 2, Get 2 Free" = 4 items)
            const bundleTitle = selectedBundle.querySelector('.kaching-bundles__bar-title, .kaching-bundles__bar-deal-name, [class*="title"]');
            if (bundleTitle) {
              const titleText = bundleTitle.textContent || '';
              console.log('[Monogram] Bundle title:', titleText);
              
              // Parse "Buy X, Get Y Free" pattern
              const buyGetMatch = titleText.match(/buy\s*(\d+).*get\s*(\d+)/i);
              if (buyGetMatch) {
                const buyCount = parseInt(buyGetMatch[1]) || 0;
                const getCount = parseInt(buyGetMatch[2]) || 0;
                const totalCount = buyCount + getCount;
                console.log('[Monogram] Parsed from title: Buy', buyCount, '+ Get', getCount, '=', totalCount, 'items');
                return totalCount;
              }
              
              // Parse simple number pattern (e.g., "4 Items Bundle")
              const numberMatch = titleText.match(/(\d+)/);
              if (numberMatch) {
                const count = parseInt(numberMatch[1]);
                if (count > 0 && count <= 10) {
                  console.log('[Monogram] Parsed count from title:', count);
                  return count;
                }
              }
            }
            
            // Method 3: Count items by looking for numbered elements (e.g., #1, #2, #3, #4)
            const numberedItems = selectedBundle.querySelectorAll('[class*="item-number"], [class*="item_number"], .kaching-bundles__bar-item');
            if (numberedItems.length > 0) {
              console.log('[Monogram] Bundle item count from numbered items:', numberedItems.length);
              return numberedItems.length;
            }
            
            // Method 4: Count color/variant dropdowns
            const colorSelects = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-select');
            if (colorSelects.length > 0) {
              // Usually 2 selects per item (color + size), so divide by 2
              const possibleCount = Math.ceil(colorSelects.length / 2);
              console.log('[Monogram] Bundle item count from selects:', possibleCount, '(from', colorSelects.length, 'selects)');
              return possibleCount;
            }
            
            console.log('[Monogram] Could not determine bundle item count, defaulting to 1');
            return 1;
          }
          
          // Generate monogram items
          function generateMonogramItems(itemCount) {
            if (!monogramItemsContainer || !monogramItemTemplate) return;
            
            monogramItemsContainer.innerHTML = '';
            monogramItemsData = [];
            
            const templateItem = monogramItemTemplate.querySelector('.monogram-item');
            if (!templateItem) return;
            
            // Get current variant ID to use correct images
            const productForm = document.getElementById(formId);
            let currentVariantId = mainProductId;
            if (productForm) {
              const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
              if (variantIdInput) {
                if (variantIdInput.tagName === 'SELECT') {
                  currentVariantId = variantIdInput.options[variantIdInput.selectedIndex]?.value || mainProductId;
                } else {
                  currentVariantId = variantIdInput.value || mainProductId;
                }
              }
            }
            currentVariantId = parseInt(currentVariantId);
            console.log('[Monogram] Generating', itemCount, 'monogram items for variant ID:', currentVariantId);
            
            for (let i = 0; i < itemCount; i++) {
              const itemClone = templateItem.cloneNode(true);
              const monogramItem = itemClone;
              
              monogramItem.dataset.itemIndex = i;
              
              const itemNumberSpan = monogramItem.querySelector('.monogram-item-number');
              if (itemNumberSpan) {
                itemNumberSpan.textContent = (i + 1);
              }
              
              const styleSelect = monogramItem.querySelector('.monogram-style-select-item');
              const colorSelect = monogramItem.querySelector('.monogram-color-select-item');
              const textInput = monogramItem.querySelector('.monogram-text-input-item');
              const previewText = monogramItem.querySelector('.monogram-preview-text-item');
              const imageContainer = monogramItem.querySelector('.monogram-image-container-item');
              const addedBadge = monogramItem.querySelector('.monogram-added-badge');
              
              // Update images for current variant if variant has images
              if (imageContainer && variantImagesData[currentVariantId] && variantImagesData[currentVariantId].images && variantImagesData[currentVariantId].images.length > 0) {
                console.log('[Monogram] Using variant-specific images for item', i);
                // Remove template images
                const existingImages = imageContainer.querySelectorAll('.monogram-base-image');
                existingImages.forEach(function(img) {
                  img.remove();
                });
                
                // Add variant-specific images
                const variantData = variantImagesData[currentVariantId];
                variantData.images.forEach(function(imgData, index) {
                  const newImg = document.createElement('img');
                  newImg.className = 'monogram-base-image';
                  newImg.setAttribute('data-variant-id', currentVariantId);
                  newImg.setAttribute('data-image-source', 'variant');
                  newImg.src = imgData.src;
                  newImg.alt = imgData.alt;
                  newImg.loading = 'lazy';
                  newImg.width = 600;
                  newImg.height = 600;
                  newImg.style.display = index === 0 ? 'block' : 'none';
                  
                  if (previewText) {
                    imageContainer.insertBefore(newImg, previewText);
                  } else {
                    imageContainer.appendChild(newImg);
                  }
                });
              } else {
                console.log('[Monogram] Using template images for item', i, '(will be updated after all items are created)');
              }
              
              const itemData = {
                index: i,
                styleSelect: styleSelect,
                colorSelect: colorSelect,
                textInput: textInput,
                previewText: previewText,
                imageContainer: imageContainer,
                addedBadge: addedBadge,
                position: { x: 50, y: 50 }
              };
              monogramItemsData.push(itemData);
              
              if (previewText) {
                previewText.style.position = 'absolute';
                previewText.style.top = '50%';
                previewText.style.left = '42%';
                previewText.style.transform = 'translate(-50%, -50%)';
                previewText.style.color = '#000000';
                previewText.style.display = 'block';
                previewText.style.zIndex = '10';
                previewText.style.fontSize = '36px';
                previewText.style.fontWeight = '400';
                previewText.style.textTransform = 'none';
                previewText.style.whiteSpace = 'nowrap';
                previewText.style.cursor = 'move';
                previewText.style.pointerEvents = 'auto';
              }
              
              initMonogramItemInteractions(itemData);
              monogramItemsContainer.appendChild(monogramItem);
            }
            
            updateMonogramButton();
            updateMonogramTotalPrice();
            updateATCButtonState();
          }
          
          // Initialize monogram item interactions
          function initMonogramItemInteractions(itemData) {
            if (!itemData || !itemData.previewText || !itemData.imageContainer) return;
            
            function updateItemPreviewText() {
              const text = itemData.textInput ? itemData.textInput.value : '';
              itemData.previewText.textContent = text;
              
              if (itemData.addedBadge) {
                itemData.addedBadge.style.display = text.trim().length > 0 ? 'inline-block' : 'none';
              }
              
              if (itemData.colorSelect && itemData.colorSelect.value) {
                const color = itemData.colorSelect.value.toLowerCase();
                itemData.previewText.style.color = color;
              } else {
                itemData.previewText.style.color = '#000000';
              }
              
              if (itemData.styleSelect && itemData.styleSelect.value) {
                let fontName = itemData.styleSelect.value;
                const selectedOption = itemData.styleSelect.options[itemData.styleSelect.selectedIndex];
                const fontUrl = selectedOption ? selectedOption.dataset.url : null;
                
                // Logic to handle Google Fonts specifically and bypass potential broken Metaobject URLs
                const isPlayfair = fontName.toLowerCase().includes('playfair');
                const isPinyon = fontName.toLowerCase().includes('pinyon');
                
                if (isPlayfair) {
                  itemData.previewText.style.fontFamily = '"Playfair Display", serif';
                  console.log('[Monogram] Applied Playfair Display via Google Fonts');
                } else if (isPinyon) {
                  itemData.previewText.style.fontFamily = '"Pinyon Script", cursive';
                  console.log('[Monogram] Applied Pinyon Script via Google Fonts');
                } else if (fontUrl && fontName) {
                  console.log('[Monogram] Loading custom font:', fontName, fontUrl);
                  loadFont(fontName, fontUrl).then(function() {
                    console.log('[Monogram] Custom font loaded successfully:', fontName);
                    itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                  }).catch(function(err) {
                    console.error('[Monogram] Custom font loading failed for:', fontName, err);
                    itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                  });
                } else {
                  itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                }
              } else {
                itemData.previewText.style.fontFamily = 'inherit';
              }
            }
            
            // Initial update
            updateItemPreviewText();
            
            if (itemData.textInput) {
              itemData.textInput.addEventListener('input', function() {
                updateItemPreviewText();
                updateMonogramTotalPrice();
                updateATCButtonState();
                updateMonogramButton();
              });
            }
            
            if (itemData.colorSelect) {
              itemData.colorSelect.addEventListener('change', updateItemPreviewText);
            }
            
            if (itemData.styleSelect) {
              itemData.styleSelect.addEventListener('change', updateItemPreviewText);
            }
            
            // Sync image with bundle color (for bundle items)
            function syncImageWithBundleColor() {
              if (isBundleSelected()) {
                const bundleColor = getBundleColorForItem(itemData.index);
                if (bundleColor) {
                  updateSingleMonogramItemImage(itemData.index, bundleColor);
                }
              }
            }
            
            // Store sync function for external calls
            itemData.syncImageWithBundle = syncImageWithBundleColor;
            
            // Drag and drop for text positioning
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            let startX = 0;
            let startY = 0;
            
            itemData.previewText.addEventListener('mousedown', function(e) {
              isDragging = true;
              dragStartX = e.clientX;
              dragStartY = e.clientY;
              
              const rect = itemData.imageContainer.getBoundingClientRect();
              const currentLeft = parseFloat(itemData.previewText.style.left) || 50;
              const currentTop = parseFloat(itemData.previewText.style.top) || 50;
              
              startX = (currentLeft / 100) * rect.width;
              startY = (currentTop / 100) * rect.height;
              
              e.preventDefault();
            });
            
            const handleMouseMove = function(e) {
              if (!isDragging || !itemData.previewText || !itemData.imageContainer) return;
              
              const rect = itemData.imageContainer.getBoundingClientRect();
              const deltaX = e.clientX - dragStartX;
              const deltaY = e.clientY - dragStartY;
              
              let newX = startX + deltaX;
              let newY = startY + deltaY;
              
              newX = Math.max(0, Math.min(rect.width, newX));
              newY = Math.max(0, Math.min(rect.height, newY));
              
              const percentX = (newX / rect.width) * 100;
              const percentY = (newY / rect.height) * 100;
              
              itemData.previewText.style.left = percentX + '%';
              itemData.previewText.style.top = percentY + '%';
              itemData.previewText.style.transform = 'translate(-50%, -50%)';
              
              itemData.position.x = percentX;
              itemData.position.y = percentY;
            };
            
            const handleMouseUp = function() {
              isDragging = false;
            };
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          }
          
          // Load font
          function loadFont(fontName, fontUrl) {
            if (loadedFonts[fontName]) {
              return Promise.resolve();
            }
            
            return new Promise(function(resolve, reject) {
              const fontFace = new FontFace(fontName, `url(${fontUrl})`);
              fontFace.load().then(function(loadedFace) {
                document.fonts.add(loadedFace);
                loadedFonts[fontName] = true;
                resolve();
              }).catch(reject);
            });
          }
          
          // Toggle monogram box
          if (toggleBtn && monogramBox) {
            toggleBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              console.log('[Monogram] Toggle button clicked');
              const wasVisible = monogramBox.style.display !== 'none';
              isMonogramBoxOpen = !wasVisible;
              
              if (wasVisible) {
                // If closing (removing), clear all inputs
                if (monogramItemsData) {
                  monogramItemsData.forEach(function(item) {
                    if (item.textInput) item.textInput.value = '';
                    if (item.previewText) item.previewText.textContent = '';
                  });
                }
                if (checkboxTerms) checkboxTerms.checked = false;
              }

              monogramBox.style.display = wasVisible ? 'none' : 'block';
              console.log('[Monogram] Monogram box display set to:', monogramBox.style.display);
              
              if (monogramBox.style.display === 'block') {
                // Get bundle item count - will parse from bundle title if needed
                currentBundleItemCount = getSelectedBundleItemCount();
                console.log('[Monogram] Opening monogram box, generating', currentBundleItemCount, 'monogram items');
                generateMonogramItems(currentBundleItemCount);
                updateATCButtonState();
                
                // After generating items, update images based on bundle colors or variant
                setTimeout(function() {
                  // Priority 1: If bundle is selected, use bundle colors for each item INDIVIDUALLY
                  if (isBundleSelected() && monogramItemsData.length > 0) {
                    console.log('[Monogram] Bundle is selected - initializing each item with its own bundle color');
                    const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
                    if (selectedBundle) {
                      const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
                      console.log('[Monogram] Found', variantWrappers.length, 'bundle variant wrappers');
                      
                      variantWrappers.forEach(function(wrapper, index) {
                        if (index < monogramItemsData.length) {
                          // Try multiple selectors for color dropdown
                          let colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
                          if (!colorSelect) {
                            colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
                          }
                          if (!colorSelect) {
                            // Fallback: get the first select in the wrapper
                            colorSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
                          }
                          
                          if (colorSelect) {
                            const colorValue = colorSelect.value;
                            console.log('[Monogram] Bundle item', index, '- found color:', colorValue);
                            if (colorValue) {
                              updateSingleMonogramItemImage(index, colorValue);
                            }
                          } else {
                            console.warn('[Monogram] No color select found for bundle item', index);
                          }
                        }
                      });
                    } else {
                      console.warn('[Monogram] Selected bundle element not found');
                    }
                  } else {
                    // Priority 2: Use main product variant
                    const productForm = document.getElementById(formId);
                    if (productForm) {
                      const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
                      let currentVariantId = null;
                      if (variantIdInput) {
                        if (variantIdInput.tagName === 'SELECT') {
                          currentVariantId = variantIdInput.options[variantIdInput.selectedIndex]?.value;
                        } else {
                          currentVariantId = variantIdInput.value;
                        }
                      }
                      if (currentVariantId && monogramItemsData.length > 0) {
                        const variantIdInt = parseInt(currentVariantId);
                        console.log('[Monogram] Updating images for current variant after opening box:', variantIdInt);
                        updateMonogramImagesForVariant(variantIdInt);
                      }
                    }
                  }
                }, 150);
              } else {
                updateATCButtonState();
              }
              
              updateMonogramButton();
              updateMonogramTotalPrice();
            });
          } else {
            console.error('[Monogram] Cannot setup toggle - toggleBtn:', !!toggleBtn, 'monogramBox:', !!monogramBox);
          }
          
          // Bundle detection
          function initBundleDetection() {
            // Track previous bundle to detect actual changes
            let previousBundleId = null;
            
            // Function to handle bundle change
            function handleBundleChange() {
              const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
              const currentBundleId = selectedBundle ? selectedBundle.getAttribute('data-deal-id') || selectedBundle.id || 'unknown' : null;
              
              console.log('[Monogram] handleBundleChange called, selected bundle:', currentBundleId, 'previous:', previousBundleId);
              
              // Only process if bundle actually changed
              if (currentBundleId === previousBundleId && currentBundleId !== 'unknown') {
                console.log('[Monogram] Bundle unchanged, skipping');
                return;
              }
              previousBundleId = currentBundleId;
              
              console.log('[Monogram] Bundle changed to:', currentBundleId);
              
              // Wait a bit for DOM to fully update after bundle selection
              setTimeout(function() {
                const itemCount = getSelectedBundleItemCount();
                currentBundleItemCount = itemCount;
                console.log('[Monogram] New bundle has', itemCount, 'monogram items');
                
                if (isMonogramBoxOpen) {
                  console.log('[Monogram] Bundle changed - closing monogram box to reset state and enable ATC');
                  // Close the box to prevent "Disabled ATC" state with empty inputs
                  isMonogramBoxOpen = false;
                  if (monogramBox) monogramBox.style.display = 'none';
                  
                  // Clear items
                  monogramItemsData = [];
                  if (monogramItemsContainer) monogramItemsContainer.innerHTML = '';
                  
                  // Update UI
                  updateMonogramButton();
                  updateATCButtonState();
                } else {
                   // Even if closed, ensure ATC state is correct
                   updateATCButtonState();
                }
              }, 150); // Wait for DOM to update
            }
            
            // Listen for bundle selection changes (switching between different bundle deals)
            document.addEventListener('change', function(e) {
              if (e.target.matches('input[name^="kaching-bundles-deal"]')) {
                console.log('[Monogram] Bundle deal radio changed');
                // Only prevent scroll, let bundle app handle its own updates
                e.stopPropagation();
                setTimeout(handleBundleChange, 100);
              }
              
              // Listen for bundle color dropdown changes
              // Listen to any select changes within kaching bundles variant wrappers
              if (e.target.matches('.kaching-bundles__bar-variant-select') && e.target.closest('.kaching-bundles__bar--selected')) {
                const selectName = e.target.getAttribute('data-name') || '';
                const wrapper = e.target.closest('.kaching-bundles__bar-variant-selector-wrapper');
                console.log('[Monogram] Bundle dropdown changed - name:', selectName, 'value:', e.target.value);
                
                // Determine if this is the color-related dropdown
                // Check multiple conditions: data-name="Color", data-name="Colour", or it's the first select in the wrapper
                let isColorDropdown = false;
                if (selectName.toLowerCase() === 'color' || selectName.toLowerCase() === 'colour') {
                  isColorDropdown = true;
                } else if (wrapper) {
                  // Check if this is the first select (often color is first)
                  const allSelects = wrapper.querySelectorAll('.kaching-bundles__bar-variant-select');
                  isColorDropdown = allSelects[0] === e.target;
                }
                
                if (!isColorDropdown) {
                  console.log('[Monogram] Not a color dropdown (name:', selectName, '), ignoring');
                  return;
                }
                
                // Only prevent scroll if we're actually handling monogram updates
                if (isMonogramBoxOpen && monogramItemsData.length > 0) {
                  // Stop propagation to prevent scroll-to-top, but allow bundle app to handle variant changes
                  e.stopPropagation();
                }
                
                console.log('[Monogram] Color dropdown detected, will update corresponding monogram item');
                
                // Use setTimeout to ensure this runs AFTER any variant change events
                setTimeout(function() {
                  // Find which bundle item this color dropdown belongs to
                  const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
                  if (selectedBundle && isMonogramBoxOpen && monogramItemsData.length > 0) {
                    const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
                    
                    if (wrapper) {
                      // Find the index of this wrapper
                      const itemIndex = Array.from(variantWrappers).indexOf(wrapper);
                      console.log('[Monogram] Color changed for bundle item index:', itemIndex, '- color:', e.target.value);
                      
                      // Update ONLY the corresponding monogram item's image
                      if (itemIndex >= 0 && itemIndex < monogramItemsData.length) {
                        const selectedColor = e.target.value;
                        console.log('[Monogram] Updating ONLY monogram item', itemIndex, 'to show image for color:', selectedColor);
                        updateSingleMonogramItemImage(itemIndex, selectedColor);
                        updateATCButtonState(); // Ensure ATC button is re-enabled if it was disabled during color change
                      } else {
                        console.warn('[Monogram] Item index out of range:', itemIndex, 'total items:', monogramItemsData.length);
                      }
                    } else {
                      console.warn('[Monogram] Could not find wrapper for color dropdown');
                    }
                  } else {
                    console.log('[Monogram] Bundle not selected or monogram box not open');
                  }
                }, 100); // Delay to ensure we process after any variant change events
              }
            });
            
            // Also listen for clicks on bundle bars (in case radio change doesn't fire)
            document.addEventListener('click', function(e) {
              const bundleBar = e.target.closest('.kaching-bundles__bar');
              if (bundleBar && !bundleBar.classList.contains('kaching-bundles__bar--selected')) {
                console.log('[Monogram] Bundle bar clicked');
                // Wait for the bundle to become selected
                setTimeout(handleBundleChange, 200);
              }
            });
            
            // Initial bundle detection on page load
            setTimeout(function() {
              currentBundleItemCount = getSelectedBundleItemCount();
              console.log('[Monogram] Initial bundle detection - item count:', currentBundleItemCount);
              if (monogramBox.style.display !== 'none') {
                generateMonogramItems(currentBundleItemCount);
                
                // If bundle is selected, read colors and update images
                if (isBundleSelected()) {
                  setTimeout(function() {
                    console.log('[Monogram] Initial load - reading bundle colors');
                    updateAllMonogramItemsFromBundleColors();
                  }, 150);
                }
              }
            }, 500);
          }
          
          // Store variant images data for all variants (populated from Liquid template)
          // MUST be defined early so it's available when generateMonogramItems is called
          const variantImagesData = {
            {%- for variant in product.variants -%}
              {{ variant.id }}: {
                {%- assign variant_imgs = variant.metafields.custom.variant_monogram_images -%}
                {%- if variant_imgs != blank and variant_imgs.value.size > 0 -%}
                  images: [
                    {%- for img in variant_imgs.value -%}
                      {
                        src: {{ img | image_url: width: 600 | json }},
                        alt: {{ product.title | append: ' - ' | append: variant.title | json }}
                      }{% unless forloop.last %},{% endunless %}
                    {%- endfor -%}
                  ],
                  source: 'variant',
                  variantTitle: {{ variant.title | json }}
                {%- else -%}
                  images: null,
                  source: 'fallback',
                  variantTitle: {{ variant.title | json }}
                {%- endif -%}
              }{% unless forloop.last %},{% endunless %}
            {%- endfor -%}
          };
          
          // Store product-level images data for fallback (populated from Liquid template)
          const productImagesData = {
            {%- assign product_images = product.metafields.custom.monogram_images -%}
            {%- assign monogram_colors = product.metafields.custom.monogram_colors1.value -%}
            {%- if product_images != blank and product_images.value.size > 0 -%}
              images: [
                {%- for img in product_images.value -%}
                  {
                    src: {{ img | image_url: width: 600 | json }},
                    color: {%- assign color_index = forloop.index0 -%}{%- if monogram_colors[color_index] != blank -%}{{ monogram_colors[color_index] | json }}{%- else -%}'default'{%- endif -%},
                    colorIndex: {{ color_index }}
                  }{% unless forloop.last %},{% endunless %}
                {%- endfor -%}
              ],
              colors: [
                {%- if monogram_colors != blank -%}
                  {%- for color in monogram_colors -%}
                    {{ color | json }}{% unless forloop.last %},{% endunless %}
                  {%- endfor -%}
                {%- endif -%}
              ],
              hasImages: true
            {%- else -%}
              images: null,
              colors: [],
              hasImages: false
            {%- endif -%}
          };
          
          console.log('[Monogram] Loaded variant images data for', Object.keys(variantImagesData).length, 'variants');
          console.log('[Monogram] Variants with images:', Object.keys(variantImagesData).filter(function(id) {
            return variantImagesData[id].images && variantImagesData[id].images.length > 0;
          }).map(function(id) {
            return id + ' (' + variantImagesData[id].variantTitle + ')';
          }));
          console.log('[Monogram] Product-level images available:', productImagesData.hasImages, '-', productImagesData.images ? productImagesData.images.length : 0, 'images');
          
          initBundleDetection();
          updateMonogramButton();
          updateMonogramTotalPrice();
          updateATCButtonState();
          
          // Update monogram images when variant changes (VARIANT-LEVEL APPROACH - PRIORITY)
          // NOTE: This function updates ALL monogram items to the same variant's images
          // When a bundle is selected, it redirects to update from bundle colors instead
          function updateMonogramImagesForVariant(variantId) {
            if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
              console.log('[Monogram] Skipping image update - box closed or no items');
              return;
            }
            
            // If a bundle is selected, update from bundle colors instead
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - redirecting to bundle color update');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            const variantIdInt = parseInt(variantId);
            console.log('[Monogram] Updating images for variant ID:', variantIdInt);
            
            const variantData = variantImagesData[variantIdInt];
            
            if (variantData) {
              console.log('[Monogram] Variant data found:', {
                variantId: variantIdInt,
                variantTitle: variantData.variantTitle,
                hasImages: !!(variantData.images && variantData.images.length > 0),
                imageCount: variantData.images ? variantData.images.length : 0,
                source: variantData.source
              });
            } else {
              console.warn('[Monogram] Variant data NOT found for ID:', variantIdInt);
              console.warn('[Monogram] Available variant IDs:', Object.keys(variantImagesData).map(function(id) {
                return id + ' (' + variantImagesData[id].variantTitle + ')';
              }));
              return;
            }
            
            if (variantData && variantData.images && variantData.images.length > 0) {
              console.log('[Monogram] Variant has', variantData.images.length, 'images - using variant-level images');
              
              monogramItemsData.forEach(function(itemData) {
                if (itemData.imageContainer) {
                  const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                  
                  // Remove old images
                  existingImages.forEach(function(img) {
                    img.remove();
                  });
                  
                  // Add new images for this variant
                  variantData.images.forEach(function(imgData, index) {
                    const newImg = document.createElement('img');
                    newImg.className = 'monogram-base-image';
                    newImg.setAttribute('data-variant-id', variantIdInt);
                    newImg.setAttribute('data-image-source', 'variant');
                    newImg.src = imgData.src;
                    newImg.alt = imgData.alt;
                    newImg.loading = 'lazy';
                    newImg.width = 600;
                    newImg.height = 600;
                    newImg.style.display = index === 0 ? 'block' : 'none';
                    
                    const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
                    if (previewText) {
                      itemData.imageContainer.insertBefore(newImg, previewText);
                    } else {
                      itemData.imageContainer.appendChild(newImg);
                    }
                  });
                  
                  console.log('[Monogram] Updated images for monogram item', itemData.index);
                }
              });
              
              console.log('[Monogram] Successfully updated images for variant', variantIdInt);
            } else {
              // Variant has no variant-level images - fallback to product-level images with color matching
              console.log('[Monogram] Variant has no variant-level images, falling back to product-level images');
              
              if (productImagesData.hasImages && productImagesData.images && productImagesData.images.length > 0) {
                console.log('[Monogram] Using product-level images with color matching');
                
                // Get color from variant title or form options
                const variantData = variantImagesData[variantIdInt];
                let selectedColor = null;
                
                if (variantData && variantData.variantTitle) {
                  // Try to extract color from variant title (e.g., "Limited Edition: Wine Red / Full 50x60 in" -> "Wine Red")
                  const variantTitle = variantData.variantTitle;
                  console.log('[Monogram] Extracting color from variant title:', variantTitle);
                  
                  // Extract color from variant title - look for common color patterns
                  const colorMatch = variantTitle.match(/\b(Black|White|Red|Blue|Green|Gold|Silver|Navy|Gray|Grey|Brown|Beige|Pink|Purple|Orange|Yellow|Wine Red|Wine|Cream|Ivory|Tan|Maroon|Burgundy|Teal|Turquoise|Coral|Lavender|Mint|Peach|Salmon|Olive|Khaki)\b/i);
                  if (colorMatch) {
                    selectedColor = colorMatch[1];
                    console.log('[Monogram] Extracted color from variant title:', selectedColor);
                  }
                }
                
                // If no color found in title, try to get from form options
                if (!selectedColor) {
                  const productForm = document.getElementById(formId);
                  if (productForm) {
                    const colorInputs = productForm.querySelectorAll('input[type="radio"][name*="Color"]:checked, select[name*="Color"]');
                    if (colorInputs.length > 0) {
                      selectedColor = colorInputs[0].value || colorInputs[0].options[colorInputs[0].selectedIndex]?.value;
                      console.log('[Monogram] Got color from form options:', selectedColor);
                    }
                  }
                }
                
                // Also check bundle color if bundle is selected
                if (!selectedColor && isBundleSelected()) {
                  selectedColor = getBundleColorForItem(0);
                  console.log('[Monogram] Got color from bundle:', selectedColor);
                }
                
                // Update images with color matching (will show first image if no color found)
                updateMonogramImagesByColor(selectedColor);
              } else {
                console.log('[Monogram] No product-level images available, keeping existing template images');
              }
            }
          }
          
          // Get color from bundle dropdown for a specific item index
          function getBundleColorForItem(itemIndex) {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return null;
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (itemIndex >= variantWrappers.length) return null;
            
            const wrapper = variantWrappers[itemIndex];
            const colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
            if (!colorSelect) {
              // Fallback: try Colour or first select
              const colourSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
              if (colourSelect) return colourSelect.value || null;
              const firstSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
              if (firstSelect) return firstSelect.value || null;
              return null;
            }
            
            return colorSelect.value || null;
          }
          
          // Get variant ID for a specific bundle item index (using same methods as extractBundleVariantIds)
          function getBundleVariantIdForItem(itemIndex) {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return null;
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (itemIndex >= variantWrappers.length) return null;
            
            const wrapper = variantWrappers[itemIndex];
            let variantId = null;
            
            // Method 1: Try data-variant-id attribute on wrapper
            const dataVariantId = wrapper.getAttribute('data-variant-id');
            if (dataVariantId) {
              const testId = parseInt(dataVariantId);
              if (!isNaN(testId) && testId > 0) {
                variantId = testId;
              }
            }
            
            // Method 2: Try hidden input
            if (!variantId) {
              const hiddenInput = wrapper.querySelector('input[type="hidden"]');
              if (hiddenInput && hiddenInput.value) {
                const testId = parseInt(hiddenInput.value);
                if (!isNaN(testId) && testId > 0) {
                  variantId = testId;
                }
              }
            }
            
            // Method 3: Try [name="id"] input
            if (!variantId) {
              const idInput = wrapper.querySelector('[name="id"]');
              if (idInput && idInput.value) {
                const testId = parseInt(idInput.value);
                if (!isNaN(testId) && testId > 0) {
                  variantId = testId;
                }
              }
            }
            
            // Method 4: Try select - check selected option value
            if (!variantId) {
              const variantSelect = wrapper.querySelector('select');
              if (variantSelect) {
                const selectedOption = variantSelect.options[variantSelect.selectedIndex];
                if (selectedOption && selectedOption.value) {
                  const testId = parseInt(selectedOption.value);
                  if (!isNaN(testId) && testId > 0) {
                    variantId = testId;
                  }
                }
                if (!variantId && variantSelect.value) {
                  const testId = parseInt(variantSelect.value);
                  if (!isNaN(testId) && testId > 0) {
                    variantId = testId;
                  }
                }
              }
            }
            
            // Method 5: Try any input with variant/id in name
            if (!variantId) {
              const variantInputs = wrapper.querySelectorAll('input[name*="variant"], input[name*="id"]');
              variantInputs.forEach(function(input) {
                if (!variantId && input.value) {
                  const testId = parseInt(input.value);
                  if (!isNaN(testId) && testId > 1000000) {
                    variantId = testId;
                  }
                }
              });
            }
            
            // Method 6: Scan all inputs for large numbers (variant IDs)
            if (!variantId) {
              const allInputs = wrapper.querySelectorAll('input, select');
              allInputs.forEach(function(input) {
                if (!variantId) {
                  let value = input.value;
                  if (!value && input.tagName === 'SELECT') {
                    const selectedOption = input.options[input.selectedIndex];
                    value = selectedOption ? selectedOption.value : null;
                  }
                  if (!value) {
                    value = input.getAttribute('value');
                  }
                  if (value) {
                    const testId = parseInt(value);
                    if (!isNaN(testId) && testId > 1000000) {
                      variantId = testId;
                    }
                  }
                }
              });
            }
            
            return variantId;
          }
          
          // Get variant color/title for a monogram item
          // For bundles: gets full variant title from bundle item at itemIndex
          // For single products: gets full variant title from selected variant
          function getVariantColorForMonogramItem(itemIndex) {
            let variantTitle = '';
            
            if (isBundleSelected()) {
              // Bundle selected - get variant ID and then full variant title
              const variantId = getBundleVariantIdForItem(itemIndex);
              if (variantId && variantImagesData[variantId] && variantImagesData[variantId].variantTitle) {
                variantTitle = variantImagesData[variantId].variantTitle;
                console.log('[Monogram] Got variant title from bundle item', itemIndex, ':', variantTitle);
              } else {
                // Fallback: try to construct from selected options
                const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
                if (selectedBundle) {
                  const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
                  if (itemIndex < variantWrappers.length) {
                    const wrapper = variantWrappers[itemIndex];
                    const optionSelects = wrapper.querySelectorAll('.kaching-bundles__bar-variant-select');
                    const optionParts = [];
                    optionSelects.forEach(function(select) {
                      if (select.value) {
                        optionParts.push(select.value);
                      }
                    });
                    if (optionParts.length > 0) {
                      variantTitle = optionParts.join(' / ');
                      console.log('[Monogram] Constructed variant title from bundle options:', variantTitle);
                    }
                  }
                }
              }
            } else {
              // Single product - get from selected variant
              const productForm = document.getElementById(formId);
              if (productForm) {
                const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
                if (variantIdInput) {
                  let variantId = null;
                  if (variantIdInput.tagName === 'SELECT') {
                    variantId = variantIdInput.options[variantIdInput.selectedIndex]?.value;
                  } else {
                    variantId = variantIdInput.value;
                  }
                  
                  if (variantId) {
                    const variantIdInt = parseInt(variantId);
                    if (variantImagesData[variantIdInt] && variantImagesData[variantIdInt].variantTitle) {
                      variantTitle = variantImagesData[variantIdInt].variantTitle;
                      console.log('[Monogram] Got variant title from single product:', variantTitle);
                    }
                  }
                }
              }
            }
            
            return {
              color: '', // Not needed anymore
              title: variantTitle,
              displayText: variantTitle || ''
            };
          }
          
          // Extract color name from strings like "Limited Edition: Purple" -> "Purple"
          function extractColorName(colorString) {
            if (!colorString) return '';
            
            const normalized = colorString.trim();
            
            // Common prefixes to remove
            const prefixes = [
              'Limited Edition:',
              'Limited Edition',
              'Special Edition:',
              'Special Edition',
              'Premium:',
              'Premium'
            ];
            
            let colorName = normalized;
            
            // Remove prefixes
            prefixes.forEach(function(prefix) {
              if (colorName.toLowerCase().startsWith(prefix.toLowerCase())) {
                colorName = colorName.substring(prefix.length).trim();
                // Remove leading colon if present
                if (colorName.startsWith(':')) {
                  colorName = colorName.substring(1).trim();
                }
              }
            });
            
            return colorName;
          }
          
          // Update a single monogram item's image based on color (for bundle items)
          function updateSingleMonogramItemImage(itemIndex, selectedColor) {
            if (!productImagesData.hasImages || !productImagesData.images || productImagesData.images.length === 0) {
              console.warn('[Monogram] No product-level images available for color matching');
              return;
            }
            
            if (itemIndex < 0 || itemIndex >= monogramItemsData.length) {
              console.warn('[Monogram] Invalid item index:', itemIndex);
              return;
            }
            
            const itemData = monogramItemsData[itemIndex];
            if (!itemData || !itemData.imageContainer) {
              console.warn('[Monogram] Item data or image container not found for index:', itemIndex);
              return;
            }
            
            console.log('[Monogram] Updating image for item', itemIndex, 'with color:', selectedColor);
            
            // Extract actual color name (e.g., "Limited Edition: Wine Red" -> "Wine Red")
            const extractedColor = selectedColor ? extractColorName(selectedColor) : '';
            const normalizedColor = extractedColor ? extractedColor.toLowerCase() : '';
            const originalColor = selectedColor ? selectedColor.trim().toLowerCase() : '';
            
            // Remove old images
            const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            console.log('[Monogram] Removing', existingImages.length, 'existing images from item', itemIndex);
            existingImages.forEach(function(img) {
              img.remove();
            });
            
            // Verify images were removed
            const remainingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            if (remainingImages.length > 0) {
              console.error('[Monogram] ERROR: Failed to remove all images, remaining:', remainingImages.length);
            }
            
            // Add all product-level images
            let foundMatchingImage = false;
            let matchingImageIndex = -1;
            
            // First pass: find matching image
            for (let index = 0; index < productImagesData.images.length; index++) {
              if (foundMatchingImage) break; // Exit early if match found
              
              const imgData = productImagesData.images[index];
              const imgColor = (imgData.color || '').toLowerCase();
              
              if (selectedColor) {
                // Try multiple matching strategies
                // Strategy 1: Exact match with extracted color
                if (normalizedColor && imgColor === normalizedColor) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 2: Exact match with original color
                if (originalColor && imgColor === originalColor) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 3: Contains match (either direction)
                if (normalizedColor && (imgColor.includes(normalizedColor) || normalizedColor.includes(imgColor))) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 4: Word-based matching (split color into words and try each)
                if (normalizedColor) {
                  const colorWords = normalizedColor.split(/\s+/);
                  const imgColorWords = imgColor.split(/\s+/);
                  
                  // Check if any word from selected color matches any word from image color
                  for (let i = 0; i < colorWords.length; i++) {
                    for (let j = 0; j < imgColorWords.length; j++) {
                      if (colorWords[i].length > 2 && imgColorWords[j].length > 2 && colorWords[i] === imgColorWords[j]) {
                        foundMatchingImage = true;
                        matchingImageIndex = index;
                        break;
                      }
                    }
                    if (foundMatchingImage) break;
                  }
                  if (foundMatchingImage) break;
                }
              }
            }
            
            // Second pass: create images and set visibility - ONLY show matching image, no fallback
            productImagesData.images.forEach(function(imgData, index) {
              const newImg = document.createElement('img');
              newImg.className = 'monogram-base-image';
              newImg.setAttribute('data-image-source', 'product');
              newImg.setAttribute('data-color', imgData.color || 'default');
              newImg.setAttribute('data-color-index', imgData.colorIndex || index);
              newImg.src = imgData.src;
              newImg.alt = '{{ product.title | escape }} - ' + (imgData.color || 'default');
              newImg.loading = 'lazy';
              newImg.width = 600;
              newImg.height = 600;
              
              // Only show the matching image - no fallback to first image
              const shouldShow = foundMatchingImage && matchingImageIndex === index;
              
              newImg.style.display = shouldShow ? 'block' : 'none';
              
              const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
              if (previewText) {
                itemData.imageContainer.insertBefore(newImg, previewText);
              } else {
                itemData.imageContainer.appendChild(newImg);
              }
            });
            
            // Log results
            const addedImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            const visibleImages = Array.from(addedImages).filter(function(img) { return img.style.display === 'block'; });
            
            if (selectedColor && !foundMatchingImage && normalizedColor) {
              console.warn('[Monogram] No matching image found for color:', normalizedColor, 'on item', itemIndex);
              console.warn('[Monogram] Available colors:', productImagesData.images.map(function(img) { return img.color; }));
            } else if (foundMatchingImage) {
              console.log('[Monogram] Successfully updated image for item', itemIndex, 'with color:', selectedColor, '- matched index:', matchingImageIndex);
            }
            console.log('[Monogram] Item', itemIndex, '- Total images:', addedImages.length, '- Visible images:', visibleImages.length);
          }
          
          // Update monogram images based on color matching (for product-level images)
          // Update ALL monogram images based on color matching (for product-level images)
          // NOTE: This function updates ALL monogram items to the same color
          // When a bundle is selected, it redirects to update from bundle colors instead
          function updateMonogramImagesByColor(selectedColor) {
            if (!productImagesData.hasImages || !productImagesData.images || productImagesData.images.length === 0) {
              console.warn('[Monogram] No product-level images available for color matching');
              return;
            }
            
            // If a bundle is selected, update from bundle colors instead
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - redirecting to bundle color update');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            console.log('[Monogram] Updating images by color:', selectedColor || '(no color - showing first image)');
            
            // Extract actual color name (e.g., "Limited Edition: Wine Red" -> "Wine Red")
            const extractedColor = selectedColor ? extractColorName(selectedColor) : '';
            const normalizedColor = extractedColor ? extractedColor.toLowerCase() : '';
            const originalColor = selectedColor ? selectedColor.trim().toLowerCase() : '';
            
            monogramItemsData.forEach(function(itemData) {
              if (itemData.imageContainer) {
                // Remove old images
                const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                console.log('[Monogram] Removing', existingImages.length, 'existing images from item', itemData.index);
                existingImages.forEach(function(img) {
                  img.remove();
                });
                
                // Verify images were removed
                const remainingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                if (remainingImages.length > 0) {
                  console.error('[Monogram] ERROR: Failed to remove all images, remaining:', remainingImages.length);
                }
                
                // Add all product-level images
                let foundMatchingImage = false;
                let matchingImageIndex = -1;
                
                // First pass: find matching image
                for (let index = 0; index < productImagesData.images.length; index++) {
                  if (foundMatchingImage) break; // Exit early if match found
                  
                  const imgData = productImagesData.images[index];
                  const imgColor = (imgData.color || '').toLowerCase();
                  
                  if (selectedColor) {
                    // Try multiple matching strategies
                    // Strategy 1: Exact match with extracted color
                    if (normalizedColor && imgColor === normalizedColor) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 2: Exact match with original color
                    if (originalColor && imgColor === originalColor) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 3: Contains match (either direction)
                    if (normalizedColor && (imgColor.includes(normalizedColor) || normalizedColor.includes(imgColor))) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 4: Word-based matching (split color into words and try each)
                    if (normalizedColor) {
                      const colorWords = normalizedColor.split(/\s+/);
                      const imgColorWords = imgColor.split(/\s+/);
                      
                      // Check if any word from selected color matches any word from image color
                      for (let i = 0; i < colorWords.length; i++) {
                        for (let j = 0; j < imgColorWords.length; j++) {
                          if (colorWords[i].length > 2 && imgColorWords[j].length > 2 && colorWords[i] === imgColorWords[j]) {
                            foundMatchingImage = true;
                            matchingImageIndex = index;
                            break;
                          }
                        }
                        if (foundMatchingImage) break;
                      }
                      if (foundMatchingImage) break;
                    }
                  }
                }
                
                // Second pass: create images and set visibility - ONLY show matching image, no fallback
                productImagesData.images.forEach(function(imgData, index) {
                  const newImg = document.createElement('img');
                  newImg.className = 'monogram-base-image';
                  newImg.setAttribute('data-image-source', 'product');
                  newImg.setAttribute('data-color', imgData.color || 'default');
                  newImg.setAttribute('data-color-index', imgData.colorIndex || index);
                  newImg.src = imgData.src;
                  newImg.alt = '{{ product.title | escape }} - ' + (imgData.color || 'default');
                  newImg.loading = 'lazy';
                  newImg.width = 600;
                  newImg.height = 600;
                  
                  // Only show the matching image - no fallback to first image
                  const shouldShow = foundMatchingImage && matchingImageIndex === index;
                  
                  newImg.style.display = shouldShow ? 'block' : 'none';
                  
                  const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
                  if (previewText) {
                    itemData.imageContainer.insertBefore(newImg, previewText);
                  } else {
                    itemData.imageContainer.appendChild(newImg);
                  }
                });
                
                // Log results
                const addedImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                const visibleImages = Array.from(addedImages).filter(function(img) { return img.style.display === 'block'; });
                
                if (selectedColor && !foundMatchingImage && normalizedColor) {
                  console.warn('[Monogram] No matching image found for color:', normalizedColor);
                  console.warn('[Monogram] Available colors:', productImagesData.images.map(function(img) { return img.color; }));
                }
                console.log('[Monogram] Item', itemData.index, '- Total images:', addedImages.length, '- Visible images:', visibleImages.length);
              }
            });
            
            console.log('[Monogram] Images updated by color matching');
          }
          
          // Listen for variant changes to update monogram images
          function handleVariantChange() {
            console.log('[Monogram] Variant change detected');
            
            // Only update images if monogram box is open and items exist
            if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
              console.log('[Monogram] Monogram box is closed or no items, will update when box opens');
              return;
            }
            
            // IMPORTANT: If a bundle is selected, read colors from ALL bundle dropdowns
            // and update each monogram item individually
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - updating each item from bundle colors');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            // No bundle selected - update all items based on selected variant
            const productForm = document.getElementById(formId);
            if (!productForm) {
              console.warn('[Monogram] Product form not found');
              return;
            }
            
            const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
            let currentVariantId = null;
            
            if (variantIdInput) {
              if (variantIdInput.tagName === 'SELECT') {
                currentVariantId = variantIdInput.options[variantIdInput.selectedIndex]?.value;
              } else {
                currentVariantId = variantIdInput.value;
              }
            }
            
            console.log('[Monogram] Current variant ID:', currentVariantId);
            
            if (currentVariantId) {
              console.log('[Monogram] Monogram box is open, updating images for variant');
              updateMonogramImagesForVariant(parseInt(currentVariantId));
            }
          }
          
          // Update ALL monogram items based on current bundle color selections
          function updateAllMonogramItemsFromBundleColors() {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) {
              console.warn('[Monogram] No selected bundle found');
              return;
            }
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            console.log('[Monogram] Updating all', variantWrappers.length, 'monogram items from bundle colors');
            
            variantWrappers.forEach(function(wrapper, index) {
              if (index < monogramItemsData.length) {
                // Try multiple selectors for color dropdown
                let colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
                if (!colorSelect) {
                  colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
                }
                if (!colorSelect) {
                  // Fallback: get the first select in the wrapper (often color is first)
                  colorSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
                }
                
                if (colorSelect && colorSelect.value) {
                  console.log('[Monogram] Item', index, '- setting color from bundle:', colorSelect.value);
                  updateSingleMonogramItemImage(index, colorSelect.value);
                } else {
                  console.warn('[Monogram] Item', index, '- no color found in bundle dropdown');
                }
              }
            });
            
            console.log('[Monogram] All monogram items updated from bundle colors');
          }
          
          // Setup variant change listeners
          function setupVariantChangeListeners() {
            console.log('[Monogram] Setting up variant change listeners...');
            
            // Method 1: Listen to theme's variant change event (PUB_SUB_EVENTS)
            if (typeof subscribe !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
              subscribe(PUB_SUB_EVENTS.variantChange, function(event) {
                console.log('[Monogram] Received PUB_SUB_EVENTS.variantChange event:', event);
                
                if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
                  console.log('[Monogram] Monogram box closed or no items');
                  return;
                }
                
                // If bundle is selected, update all items from bundle colors
                if (isBundleSelected()) {
                  console.log('[Monogram] Bundle selected - updating all items from bundle colors');
                  updateAllMonogramItemsFromBundleColors();
                  return;
                }
                
                // No bundle - update from variant
                if (event && event.data && event.data.variant) {
                  const variantId = event.data.variant.id;
                  console.log('[Monogram] Variant changed to:', variantId);
                  updateMonogramImagesForVariant(variantId);
                } else {
                  // Fallback: get variant ID from form
                  handleVariantChange();
                }
              });
              console.log('[Monogram] Subscribed to PUB_SUB_EVENTS.variantChange');
            } else {
              console.warn('[Monogram] PUB_SUB_EVENTS not available');
            }
            
            // Method 2: Listen to variant-selects custom element
            const variantSelects = document.querySelector('variant-selects');
            if (variantSelects) {
              variantSelects.addEventListener('change', function() {
                console.log('[Monogram] variant-selects change event detected');
                setTimeout(handleVariantChange, 150);
              });
              console.log('[Monogram] Listening to variant-selects element');
            }
            
            // Method 3: Listen to product-form element
            const productFormElement = document.getElementById('ProductForm-{{ section.id }}');
            if (productFormElement) {
              productFormElement.addEventListener('variant:change', function(e) {
                console.log('[Monogram] variant:change event detected', e);
                handleVariantChange();
              });
              console.log('[Monogram] Listening to product-form variant:change event');
            }
            
            // Method 4: Listen to direct form changes (variant selector changes)
            const productForm = document.getElementById(formId);
            if (productForm) {
              // Listen to variant input/select changes
              const variantInput = productForm.querySelector('input[name="id"], select[name="id"]');
              if (variantInput) {
                variantInput.addEventListener('change', function() {
                  console.log('[Monogram] Variant input changed directly:', variantInput.value);
                  handleVariantChange();
                });
                console.log('[Monogram] Listening to variant ID input/select');
              }
              
              // Listen to all option changes (radio buttons, selects)
              productForm.addEventListener('change', function(e) {
                // Check if it's a variant option (not monogram-related)
                if (e.target.name && e.target.name !== 'id' && !e.target.name.includes('monogram') && !e.target.closest('.monogram-box')) {
                  // Prevent scroll-to-top behavior when variant options change
                  // Only prevent if it's a variant selector, not a form submission
                  if (e.target.type === 'radio' || e.target.tagName === 'SELECT') {
                    // Save scroll position and restore it after variant change
                    const savedScrollPosition = window.scrollY || window.pageYOffset;
                    e.stopPropagation();
                    
                    // Restore scroll position after variant change processing
                    requestAnimationFrame(function() {
                      requestAnimationFrame(function() {
                        if (Math.abs(window.scrollY - savedScrollPosition) > 10) {
                          window.scrollTo({ top: savedScrollPosition, behavior: 'instant' });
                        }
                      });
                    });
                  }
                  console.log('[Monogram] Product option changed:', e.target.name, e.target.value);
                  // Small delay to let variant ID update
                  setTimeout(function() {
                    handleVariantChange();
                  }, 150);
                }
              });
              
              console.log('[Monogram] Set up direct form change listeners');
            } else {
              console.warn('[Monogram] Product form not found for variant change listeners');
            }
            
            // Method 5: Use MutationObserver to watch for variant ID changes
            const variantIdInput = document.querySelector('input[name="id"], select[name="id"]');
            if (variantIdInput) {
              const variantIdObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                    const target = mutation.target;
                    if (target.name === 'id' || target.matches('input[name="id"], select[name="id"]')) {
                      console.log('[Monogram] Variant ID value attribute changed:', target.value);
                      setTimeout(handleVariantChange, 150);
                    }
                  }
                });
              });
              
              variantIdObserver.observe(variantIdInput, {
                attributes: true,
                attributeFilter: ['value']
              });
              console.log('[Monogram] Set up MutationObserver for variant ID changes');
            }
            
            console.log('[Monogram] Variant change listeners setup complete');
          }
          
          // Setup currency change listeners
          function setupCurrencyChangeListeners() {
            console.log('[Monogram] Setting up currency change listeners...');
            
            // Method 1: Watch for changes to data-monogram-price attribute
            if (wrapper) {
              const priceObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'attributes' && mutation.attributeName === 'data-monogram-price') {
                    console.log('[Monogram] Currency/price changed detected via data attribute');
                    updateMonogramTotalPrice();
                  }
                });
              });
              
              priceObserver.observe(wrapper, {
                attributes: true,
                attributeFilter: ['data-monogram-price']
              });
              console.log('[Monogram] Set up MutationObserver for price attribute changes');
            }
            
            // Method 2: Watch for changes to price elements (currency switcher might update these)
            const priceElements = document.querySelectorAll('[data-price], .price, price-money');
            if (priceElements.length > 0) {
              const priceElementObserver = new MutationObserver(function(mutations) {
                let shouldUpdate = false;
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    shouldUpdate = true;
                  }
                  if (mutation.type === 'attributes' && 
                      (mutation.attributeName === 'data-price' || mutation.attributeName === 'data-currency')) {
                    shouldUpdate = true;
                  }
                });
                if (shouldUpdate && isMonogramBoxOpen) {
                  console.log('[Monogram] Price element changed, updating monogram price');
                  // Small delay to ensure currency conversion is complete
                  setTimeout(updateMonogramTotalPrice, 100);
                }
              });
              
              priceElements.forEach(function(element) {
                priceElementObserver.observe(element, {
                  childList: true,
                  subtree: true,
                  characterData: true,
                  attributes: true,
                  attributeFilter: ['data-price', 'data-currency']
                });
              });
              console.log('[Monogram] Set up MutationObserver for price element changes');
            }
            
            // Method 3: Listen for custom currency change events
            document.addEventListener('currency:change', function() {
              console.log('[Monogram] Currency change event detected');
              setTimeout(updateMonogramTotalPrice, 100);
            });
            
            // Method 4: Periodically check if currency format has changed (fallback)
            let lastMoneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat ? theme.shopSettings.moneyFormat : '';
            setInterval(function() {
              if (theme.shopSettings && theme.shopSettings.moneyFormat) {
                const currentMoneyFormat = theme.shopSettings.moneyFormat;
                if (currentMoneyFormat !== lastMoneyFormat) {
                  console.log('[Monogram] Currency format changed detected');
                  lastMoneyFormat = currentMoneyFormat;
                  if (isMonogramBoxOpen) {
                    updateMonogramTotalPrice();
                  }
                }
              }
            }, 1000); // Check every second
            
            console.log('[Monogram] Currency change listeners setup complete');
          }
          
          // Setup variant change listeners
          setupVariantChangeListeners();
          
          // Setup currency change listeners
          setupCurrencyChangeListeners();
          
          // Helper function to extract bundle variant IDs from DOM
          function extractBundleVariantIds() {
            const bundleVariantIds = [];
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            
            if (!selectedBundle) {
              // Try theme's native bundle-products element
              const bundleProducts = document.querySelector('bundle-products');
              if (bundleProducts) {
                const bundleIdInputs = bundleProducts.querySelectorAll('[name="id"]');
                bundleIdInputs.forEach(function(input) {
                  const variantId = parseInt(input.value);
                  if (!isNaN(variantId) && variantId > 0) {
                    bundleVariantIds.push(variantId);
                  }
                });
              }
              return bundleVariantIds;
            }
            
            // Method 1: [name="id"] inputs
            const bundleIdInputs = selectedBundle.querySelectorAll('[name="id"]');
            bundleIdInputs.forEach(function(input) {
              const variantId = parseInt(input.value);
              if (!isNaN(variantId) && variantId > 0) {
                bundleVariantIds.push(variantId);
              }
            });
            
            // Method 2: Variant selector wrappers
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            variantWrappers.forEach(function(wrapper) {
              let foundVariantId = null;
              
              // Try data-variant-id attribute
              const dataVariantId = wrapper.getAttribute('data-variant-id');
              if (dataVariantId) {
                const variantId = parseInt(dataVariantId);
                if (!isNaN(variantId) && variantId > 0) {
                  foundVariantId = variantId;
                }
              }
              
              // Try hidden input
              if (!foundVariantId) {
                const hiddenInput = wrapper.querySelector('input[type="hidden"]');
                if (hiddenInput && hiddenInput.value) {
                  const variantId = parseInt(hiddenInput.value);
                  if (!isNaN(variantId) && variantId > 0) {
                    foundVariantId = variantId;
                  }
                }
              }
              
              // Try select - check selected option
              if (!foundVariantId) {
                const variantSelect = wrapper.querySelector('select');
                if (variantSelect) {
                  const selectedOption = variantSelect.options[variantSelect.selectedIndex];
                  if (selectedOption && selectedOption.value) {
                    const variantId = parseInt(selectedOption.value);
                    if (!isNaN(variantId) && variantId > 0) {
                      foundVariantId = variantId;
                    }
                  }
                  if (!foundVariantId && variantSelect.value) {
                    const variantId = parseInt(variantSelect.value);
                    if (!isNaN(variantId) && variantId > 0) {
                      foundVariantId = variantId;
                    }
                  }
                }
              }
              
              // Try any input with variant/id in name
              if (!foundVariantId) {
                const variantInputs = wrapper.querySelectorAll('input[name*="variant"], input[name*="id"]');
                variantInputs.forEach(function(input) {
                  if (input.value) {
                    const variantId = parseInt(input.value);
                    if (!isNaN(variantId) && variantId > 1000000) {
                      foundVariantId = variantId;
                    }
                  }
                });
              }
              
              if (foundVariantId && bundleVariantIds.indexOf(foundVariantId) === -1) {
                bundleVariantIds.push(foundVariantId);
              }
            });
            
            // Method 3: Scan all inputs for large numbers (variant IDs)
            if (bundleVariantIds.length === 0) {
              const allInputs = selectedBundle.querySelectorAll('input, select');
              allInputs.forEach(function(input) {
                let value = input.value;
                if (!value && input.tagName === 'SELECT') {
                  const selectedOption = input.options[input.selectedIndex];
                  value = selectedOption ? selectedOption.value : null;
                }
                if (!value) {
                  value = input.getAttribute('value');
                }
                if (value) {
                  const variantId = parseInt(value);
                  if (!isNaN(variantId) && variantId > 1000000 && bundleVariantIds.indexOf(variantId) === -1) {
                    bundleVariantIds.push(variantId);
                  }
                }
              });
            }
            
            return bundleVariantIds;
          }
          
          // Intercept form submission
          const productForm = document.getElementById(formId);
          if (productForm) {
            // Function to add only monogram items to cart (used when bundle app handles bundle items separately)
            function addMonogramItemsToCart() {
              console.log('[Monogram] Adding monogram items to cart (bundle app handled bundle items)');
              
              if (typeof fetchConfig === 'undefined') {
                console.error('[Monogram] fetchConfig is not available.');
                return Promise.resolve();
              }
              
              const miniCart = document.querySelector('mini-cart');
              if (!miniCart) {
                console.error('[Monogram] mini-cart element not found');
                return Promise.resolve();
              }
              
              // Build monogram items array
              const monogramItems = [];
              monogramItemsData.forEach(function(itemData, itemIndex) {
                const textValue = itemData.textInput ? itemData.textInput.value.trim() : '';
                if (textValue.length > 0) {
                  let productName = '{{ product.title | escape }}';
                  
                  // Get variant info for this monogram item
                  const variantInfo = getVariantColorForMonogramItem(itemIndex);
                  
                  monogramItems.push({
                    id: parseInt(monogramProductId),
                    quantity: 1,
                    properties: {
                      'Monogram Text': textValue,
                      'Monogram Style': (function(val) {
                        if (val === 'Playfair Display') return 'Classic Serif';
                        if (val === 'Pinyon Script') return 'Elegant Script';
                        return val;
                      })((itemData.styleSelect && itemData.styleSelect.value) || ''),
                      'Monogram Color': (itemData.colorSelect && itemData.colorSelect.value) || '',
                      'Product Name': productName,
                      'Variant': variantInfo.title || variantInfo.displayText || '',
                      '_form_ref': formId,
                      '_monogram': 'true'
                    }
                  });
                }
              });
              
              if (monogramItems.length === 0) {
                console.log('[Monogram] No monogram items to add');
                return Promise.resolve();
              }
              
              console.log('[Monogram] Monogram items to add:', monogramItems);
              
              const sections = miniCart.getSectionsToRender ? miniCart.getSectionsToRender().map((section) => section.id) : [];
              const config = fetchConfig('javascript');
              config.headers['X-Requested-With'] = 'XMLHttpRequest';
              config.headers['Content-Type'] = 'application/json';
              
              const requestBody = {
                items: monogramItems,
                sections: sections,
                sections_url: window.location.pathname
              };
              
              config.body = JSON.stringify(requestBody);
              
              if (typeof miniCart.setActiveElement === 'function') {
                miniCart.setActiveElement(document.activeElement);
              }
              
              return fetch(theme.routes.cart_add_url, config)
                .then(function(response) {
                  console.log('[Monogram] Monogram items response status:', response.status);
                  if (!response.ok) {
                    return response.text().then(function(text) {
                      let errorData;
                      try {
                        errorData = JSON.parse(text);
                      } catch (e) {
                        errorData = { description: text || 'Cart error occurred' };
                      }
                      throw new Error(errorData.description || errorData.message || 'Cart error occurred');
                    });
                  }
                  return response.json();
                })
                .then(function(response) {
                  console.log('[Monogram] Monogram items added:', response);
                  if (response.status) {
                    throw new Error(response.description || response.message || 'Cart error occurred');
                  }
                  
                  // Always fetch cart and sections when adding monogram items after bundle
                  return fetch((window.Shopify && window.Shopify.routes && window.Shopify.routes.root ? window.Shopify.routes.root : '/') + 'cart.js')
                    .then(function(cartResponse) {
                      return cartResponse.json();
                    })
                    .then(function(cartData) {
                      console.log('[Monogram] Cart data after monogram add:', cartData);
                      response.item_count = cartData.item_count || 0;
                      response.items = cartData.items || [];
                      // Re-fetch sections to get correct cart state
                      const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                      return fetch(sectionUrl)
                        .then(function(sectionResponse) {
                          return sectionResponse.json();
                        })
                        .then(function(sectionData) {
                          console.log('[Monogram] Sections fetched:', Object.keys(sectionData || {}));
                          response.sections = sectionData;
                          return response;
                        });
                    });
                })
                .then(function(finalResponse) {
                  console.log('[Monogram] Final response for renderContents:', {
                    item_count: finalResponse.item_count,
                    hasSections: !!finalResponse.sections,
                    sectionKeys: Object.keys(finalResponse.sections || {})
                  });
                  
                  if (miniCart && typeof miniCart.renderContents === 'function') {
                    miniCart.renderContents(finalResponse);
                    console.log('[Monogram] miniCart.renderContents called for monogram items');
                  }
                  
                  if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                    publish(PUB_SUB_EVENTS.cartUpdate, {
                      source: 'monogram-form',
                      cartData: finalResponse,
                      cart: finalResponse,
                      sections: finalResponse.sections || {}
                    });
                    console.log('[Monogram] cartUpdate published for monogram items');
                  }
                })
                .catch(function(error) {
                  console.error('[Monogram] Error adding monogram items:', error);
                  alert('Error adding monogram: ' + (error.message || 'Please try again.'));
                })
                .finally(function() {
                  // Re-enable button after monogram items are added
                  if (atcButton) {
                    atcButton.classList.remove('loading');
                    atcButton.removeAttribute('aria-disabled');
                    const hasDataUnavailable = atcButton.hasAttribute('data-unavailable') && atcButton.getAttribute('data-unavailable') === 'true';
                    if (!hasDataUnavailable) {
                      atcButton.disabled = false;
                    }
                    console.log('[Monogram] Button re-enabled after monogram items added');
                  }
                });
            }
            
            productForm.addEventListener('submit', function(e) {
              const monogramEnabled = monogramBox && monogramBox.style.display !== 'none' && monogramItemsData.length > 0;
              const hasMonogramText = monogramItemsData.some(function(item) {
                return item.textInput && item.textInput.value.trim();
              });
              
              if (!monogramEnabled || !hasMonogramText) {
                return; // Let default form submission proceed
              }
              
              if (!checkboxTerms || !checkboxTerms.checked) {
                e.preventDefault();
                alert('Please confirm that you have double-checked your information and understand that monogram items are not eligible for return or exchange.');
                return;
              }
              
              // Check if bundle is selected and if we can find bundle items in DOM
              const bundleSelected = isBundleSelected();
              let bundleItemsFound = false;
              
              if (bundleSelected) {
                console.log('[Monogram] Bundle is selected, checking for bundle items in DOM...');
                const extractedVariantIds = extractBundleVariantIds();
                bundleItemsFound = extractedVariantIds.length > 0;
                console.log('[Monogram] Bundle items found in DOM:', bundleItemsFound, 'Count:', extractedVariantIds.length);
                if (bundleItemsFound) {
                  console.log('[Monogram] Extracted variant IDs:', extractedVariantIds);
                }
              }
              
              // If bundle is selected but items not found, let bundle app handle it first, then add monogram items
              if (bundleSelected && !bundleItemsFound) {
                console.log('[Monogram] Bundle selected but items not found in DOM - letting bundle app handle form submission');
                console.log('[Monogram] Will add monogram items after bundle app completes (800ms delay)');
                // Don't prevent default - let bundle app handle the form submission
                // Wait for bundle app to finish, then add monogram items
                setTimeout(function() {
                  console.log('[Monogram] Delayed monogram add triggered');
                  addMonogramItemsToCart();
                }, 800); // Wait 800ms for bundle app to finish
                return; // Let default form submission proceed
              }
              
              e.preventDefault();
              e.stopPropagation();
              
              // Check if fetchConfig is available (theme requirement)
              if (typeof fetchConfig === 'undefined') {
                console.error('[Monogram] fetchConfig is not available. Make sure theme global.js is loaded.');
                alert('There was an error: Theme configuration not loaded. Please refresh the page and try again.');
                return;
              }
              
              // Set loading state
              if (atcButton) {
                atcButton.setAttribute('aria-disabled', true);
                atcButton.classList.add('loading');
                atcButton.disabled = true;
              }
              
              const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
              const currentVariantId = variantIdInput ? (variantIdInput.value || (variantIdInput.options && variantIdInput.options[variantIdInput.selectedIndex]?.value)) : mainProductId;
              const currentVariantIdInt = parseInt(currentVariantId);
              
              const quantityInput = productForm.querySelector('input[name="quantity"]');
              const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
              
              if (isNaN(currentVariantIdInt) || isNaN(monogramProductId) || currentVariantIdInt <= 0 || monogramProductId <= 0) {
                if (atcButton) {
                  atcButton.classList.remove('loading');
                  atcButton.removeAttribute('aria-disabled');
                  atcButton.disabled = false;
                }
                alert('There was an error: Invalid product variant. Please refresh the page and try again.');
                return;
              }
              
              // bundleSelected is already declared above, reuse it
              const items = [];
              
              if (!bundleSelected) {
                // No bundle selected - add main product
                items.push({
                  id: parseInt(currentVariantIdInt),
                  quantity: parseInt(quantity) || 1
                });
                console.log('[Monogram] Adding main product to cart (no bundle selected)');
              } else {
                // Bundle is selected - add bundle items instead of main product
                console.log('[Monogram] Bundle is selected - extracting bundle items');
                
                // Use the helper function to extract bundle variant IDs
                const bundleVariantIds = extractBundleVariantIds();
                console.log('[Monogram] Extracted', bundleVariantIds.length, 'bundle variant IDs:', bundleVariantIds);
                
                // Add found bundle items to cart
                if (bundleVariantIds.length > 0) {
                  bundleVariantIds.forEach(function(variantId) {
                    items.push({
                      id: variantId,
                      quantity: 1
                    });
                    console.log('[Monogram] Adding bundle item to cart:', variantId);
                  });
                  console.log('[Monogram] Added', bundleVariantIds.length, 'bundle items to cart');
                } else {
                  console.warn('[Monogram] Bundle selected but no bundle items found in DOM.');
                  console.warn('[Monogram] Adding main product as fallback since bundle items not detected.');
                  
                  // If we can't find bundle items, add the main product as fallback
                  // This ensures something gets added even if bundle detection fails
                  items.push({
                    id: parseInt(currentVariantIdInt),
                    quantity: parseInt(quantity) || 1
                  });
                  console.log('[Monogram] Added main product as fallback (bundle items not found):', currentVariantIdInt);
                }
              }
              
              monogramItemsData.forEach(function(itemData, itemIndex) {
                const textValue = itemData.textInput ? itemData.textInput.value.trim() : '';
                if (textValue.length > 0) {
                  let productName = '{{ product.title | escape }}';
                  
                  // Get variant info for this monogram item
                  const variantInfo = getVariantColorForMonogramItem(itemIndex);
                  
                  const monogramItem = {
                    id: parseInt(monogramProductId),
                    quantity: 1,
                    properties: {
                      'Monogram Text': textValue,
                      'Monogram Style': (function(val) {
                        if (val === 'Playfair Display') return 'Classic Serif';
                        if (val === 'Pinyon Script') return 'Elegant Script';
                        return val;
                      })((itemData.styleSelect && itemData.styleSelect.value) || ''),
                      'Monogram Color': (itemData.colorSelect && itemData.colorSelect.value) || '',
                      'Product Name': productName,
                      'Variant': variantInfo.title || variantInfo.displayText || '',
                      '_form_ref': formId,
                      '_monogram': 'true'
                    }
                  };
                  items.push(monogramItem);
                }
              });
              
              // Add to cart using theme's native method
              console.log('[Monogram] Starting cart add process');
              console.log('[Monogram] Items to add:', items);
              
              const miniCart = document.querySelector('mini-cart');
              if (!miniCart) {
                console.error('[Monogram] mini-cart element not found');
                if (atcButton) {
                  atcButton.classList.remove('loading');
                  atcButton.removeAttribute('aria-disabled');
                  atcButton.disabled = false;
                }
                alert('Cart system not available. Please refresh the page.');
                return;
              }
              
              const sections = miniCart.getSectionsToRender ? miniCart.getSectionsToRender().map((section) => section.id) : [];
              console.log('[Monogram] Sections to render:', sections);
              
              const config = fetchConfig('javascript');
              config.headers['X-Requested-With'] = 'XMLHttpRequest';
              config.headers['Content-Type'] = 'application/json';
              
              const requestBody = {
                items: items,
                sections: sections,
                sections_url: window.location.pathname
              };
              
              console.log('[Monogram] Request body:', requestBody);
              console.log('[Monogram] Cart add URL:', theme.routes.cart_add_url);
              
              config.body = JSON.stringify(requestBody);
              
              // Set active element for cart drawer
              if (typeof miniCart.setActiveElement === 'function') {
                miniCart.setActiveElement(document.activeElement);
              }
              
              fetch(theme.routes.cart_add_url, config)
                .then(function(response) {
                  console.log('[Monogram] Response received:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                  });
                  
                  // Check response status
                  if (!response.ok) {
                    return response.text().then(function(text) {
                      console.error('[Monogram] Response not OK. Status:', response.status, 'Text:', text);
                      let errorData;
                      try {
                        errorData = JSON.parse(text);
                      } catch (e) {
                        errorData = { description: text || 'Cart error occurred', status: response.status };
                      }
                      throw new Error(errorData.description || errorData.message || 'Cart error occurred');
                    });
                  }
                  
                  // Clone response for error handling
                  const responseClone = response.clone();
                  
                  // Try to parse as JSON
                  return response.json().catch(function(parseError) {
                    console.error('[Monogram] JSON parse error:', parseError);
                    // If JSON parsing fails, try to get text and parse manually
                    return responseClone.text().then(function(text) {
                      console.error('[Monogram] Response text:', text);
                      if (!text || text.trim() === '') {
                        throw new Error('Empty response from server. Please try again.');
                      }
                      try {
                        const parsed = JSON.parse(text);
                        console.log('[Monogram] Manually parsed JSON:', parsed);
                        return parsed;
                      } catch (e) {
                        console.error('[Monogram] Failed to parse response text as JSON:', e);
                        throw new Error('Invalid server response. Please refresh the page and try again.');
                      }
                    });
                  });
                })
                .then(function(response) {
                  console.log('[Monogram] Parsed response:', response);
                  console.log('[Monogram] Response keys:', Object.keys(response || {}));
                  console.log('[Monogram] Response.item_count:', response ? response.item_count : 'undefined');
                  console.log('[Monogram] Response.sections:', response ? response.sections : 'undefined');
                  
                  // Validate response structure
                  if (!response) {
                    console.error('[Monogram] Response is null or undefined');
                    throw new Error('Invalid response from server');
                  }
                  
                  if (response.status) {
                    // Error response
                    console.error('[Monogram] Error response:', response);
                    if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                      publish(PUB_SUB_EVENTS.cartError, {
                        source: 'monogram-form',
                        errors: response.errors || response.description,
                        message: response.message,
                      });
                    }
                    throw new Error(response.description || response.message || 'Cart error occurred');
                  }
                  
                  // Helper function to ensure response has all required properties
                  function ensureResponseStructure(response) {
                    return new Promise(function(resolve) {
                      // Always fetch actual cart count when bundle is selected (bundle items may have been added separately)
                      // Or if item_count is missing from response
                      const needsCartFetch = bundleSelected || response.item_count === undefined;
                      
                      if (needsCartFetch) {
                        // Fetch cart to get actual item_count (includes bundle items if they were added separately)
                        console.log('[Monogram] Fetching cart.js to get actual item_count (bundle selected or item_count missing)');
                        fetch((window.Shopify && window.Shopify.routes && window.Shopify.routes.root ? window.Shopify.routes.root : '/') + 'cart.js')
                          .then(function(cartResponse) {
                            return cartResponse.json();
                          })
                          .then(function(cartData) {
                            console.log('[Monogram] Cart data fetched:', cartData);
                            response.item_count = cartData.item_count || 0;
                            if (!response.items) {
                              response.items = cartData.items || [];
                            }
                            // When bundle is selected, sections in response may be outdated (only show monogram items)
                            // Re-fetch sections to get the correct cart state (with bundle items included)
                            if (bundleSelected && sections.length > 0) {
                              console.log('[Monogram] Bundle selected - re-fetching sections to reflect actual cart state');
                              const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                              return fetch(sectionUrl)
                                .then(function(sectionResponse) {
                                  if (!sectionResponse.ok) {
                                    throw new Error('Failed to fetch sections');
                                  }
                                  return sectionResponse.json();
                                })
                                .then(function(sectionData) {
                                  console.log('[Monogram] Sections re-fetched for bundle:', Object.keys(sectionData || {}));
                                  response.sections = sectionData;
                                  checkSections();
                                })
                                .catch(function(sectionError) {
                                  console.error('[Monogram] Failed to re-fetch sections:', sectionError);
                                  // Use existing sections as fallback
                                  checkSections();
                                });
                            } else {
                              // Continue to sections check
                              checkSections();
                            }
                          })
                          .catch(function(cartError) {
                            console.error('[Monogram] Failed to fetch cart:', cartError);
                            // Fallback: calculate from response items if available
                            if (response.items && Array.isArray(response.items)) {
                              response.item_count = response.items.reduce(function(total, item) {
                                return total + (parseInt(item.quantity) || 0);
                              }, 0);
                              console.log('[Monogram] Calculated item_count from items array as fallback:', response.item_count);
                            } else {
                              response.item_count = 0;
                              response.items = [];
                            }
                            checkSections();
                          });
                        return; // Exit early, will resolve in promise
                      }
                      
                      // If item_count exists, calculate from items if needed
                      if (response.item_count === undefined && response.items && Array.isArray(response.items)) {
                        response.item_count = response.items.reduce(function(total, item) {
                          return total + (parseInt(item.quantity) || 0);
                        }, 0);
                        console.log('[Monogram] Calculated item_count from items array:', response.item_count);
                      }
                      
                      // Helper function to check sections and resolve
                      function checkSections() {
                        // Then, ensure sections exist
                        if (!response.sections && sections.length > 0) {
                          console.log('[Monogram] Fetching sections:', sections);
                          const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                          fetch(sectionUrl)
                            .then(function(sectionResponse) {
                              if (!sectionResponse.ok) {
                                throw new Error('Failed to fetch sections');
                              }
                              return sectionResponse.json();
                            })
                            .then(function(sectionData) {
                              console.log('[Monogram] Sections fetched:', Object.keys(sectionData || {}));
                              response.sections = sectionData;
                              resolve(response);
                            })
                            .catch(function(sectionError) {
                              console.error('[Monogram] Failed to fetch sections:', sectionError);
                              // Continue without sections
                              response.sections = {};
                              resolve(response);
                            });
                        } else {
                          // Sections already exist or not needed
                          resolve(response);
                        }
                      }
                      
                      // If we didn't need to fetch cart, check sections now
                      if (!needsCartFetch) {
                        checkSections();
                      }
                    });
                  }
                  
                  // Ensure response structure before proceeding
                  return ensureResponseStructure(response).then(function(finalResponse) {
                    console.log('[Monogram] Final response structure:', {
                      item_count: finalResponse.item_count,
                      hasSections: !!finalResponse.sections,
                      sectionKeys: finalResponse.sections ? Object.keys(finalResponse.sections) : [],
                      hasItems: !!finalResponse.items,
                      itemsLength: finalResponse.items ? finalResponse.items.length : 0
                    });
                    
                    // Validate that we have sections before calling renderContents
                    if (!finalResponse.sections || Object.keys(finalResponse.sections).length === 0) {
                      console.error('[Monogram] No sections available, cannot render cart');
                      throw new Error('Failed to load cart sections. Please refresh the page and try again.');
                    }
                    
                    // Success - update cart using theme's native method
                    console.log('[Monogram] Calling miniCart.renderContents');
                    if (typeof miniCart.renderContents === 'function') {
                      try {
                        miniCart.renderContents(finalResponse);
                        console.log('[Monogram] miniCart.renderContents called successfully');
                      } catch (renderError) {
                        console.error('[Monogram] Error in renderContents:', renderError);
                        console.error('[Monogram] Render error stack:', renderError.stack);
                        throw renderError;
                      }
                    } else {
                      console.error('[Monogram] miniCart.renderContents is not a function');
                      throw new Error('Cart render function not available');
                    }
                    
                    // Publish cart update event (match theme's structure)
                    if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                      console.log('[Monogram] Publishing cart update event');
                      const cartUpdateData = {
                        source: 'monogram-form',
                        cartData: finalResponse, // For price-per-item.js
                        cart: finalResponse,     // For cart.js onCartUpdate
                        sections: finalResponse.sections || {}
                      };
                      console.log('[Monogram] Cart update data structure:', {
                        hasCartData: !!cartUpdateData.cartData,
                        hasCart: !!cartUpdateData.cart,
                        cartItemCount: cartUpdateData.cart ? cartUpdateData.cart.item_count : 'undefined',
                        cartDataItemCount: cartUpdateData.cartData ? cartUpdateData.cartData.item_count : 'undefined'
                      });
                      publish(PUB_SUB_EVENTS.cartUpdate, cartUpdateData);
                    }
                    
                    // Dispatch custom events for compatibility
                    console.log('[Monogram] Dispatching ajaxProduct:added event');
                    document.dispatchEvent(new CustomEvent('ajaxProduct:added', {
                      detail: {
                        product: finalResponse
                      }
                    }));
                    
                    // Remove is-empty class if present
                    if (miniCart && miniCart.classList && miniCart.classList.contains('is-empty')) {
                      miniCart.classList.remove('is-empty');
                      console.log('[Monogram] Removed is-empty class from mini-cart');
                    }
                    
                    console.log('[Monogram] Cart add completed successfully');
                  });
                })
                .catch(function(error) {
                  console.error('[Monogram] ========== CART ADD ERROR ==========');
                  console.error('[Monogram] Error object:', error);
                  console.error('[Monogram] Error message:', error.message);
                  console.error('[Monogram] Error stack:', error.stack);
                  
                  // Show error message
                  const errorMessage = error.message || 'There was an error adding the product to cart. Please try again.';
                  alert('Error: ' + errorMessage);
                  
                  // Dispatch error event
                  document.dispatchEvent(new CustomEvent('ajaxProduct:error', {
                    detail: {
                      errorMessage: errorMessage
                    }
                  }));
                })
                .finally(function() {
                  console.log('[Monogram] Finally block - cleaning up');
                  // Re-enable submit button
                  if (atcButton) {
                    atcButton.classList.remove('loading');
                    atcButton.removeAttribute('aria-disabled');
                    const isUnavailable = atcButton.hasAttribute('data-unavailable') && atcButton.getAttribute('data-unavailable') === 'true';
                    if (!isUnavailable) {
                      atcButton.disabled = false;
                    }
                    console.log('[Monogram] Submit button re-enabled');
                  }
                });
            }, true); // Use capture phase to intercept before product-form.js
          }
        });
      })();
      </script>
    {%- endif -%}
  {%- endif -%}
{%- endif -%}
</div>