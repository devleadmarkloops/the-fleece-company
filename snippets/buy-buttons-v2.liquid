{% comment %}
  Renders product buy-buttons.
  Accepts:
  - product: {Object} product object.
  - block: {Object} passing the block information.
  - product_form_id: {String} product form id.
  - section_id: {String} id of section to which this snippet belongs.
  - show_pickup_availability:: {Boolean} for the pickup availability. If true the pickup availability is rendered, false - not rendered (optional).
  Usage:
  {% render 'buy-buttons', block: block, product: product, product_form_id: product_form_id, show_pickup_availability: true %}
{% endcomment %}
<div {{ block.shopify_attributes }}>
{%- if product != blank -%}
  {%- liquid
    assign gift_card_recipient_feature_active = false
    if block.settings.show_gift_card_recipient and product.gift_card?
      assign gift_card_recipient_feature_active = true
    endif

    assign show_dynamic_checkout = false
    if block.settings.show_dynamic_checkout and gift_card_recipient_feature_active == false
      assign show_dynamic_checkout = true
    endif
  -%}
  <product-form 
    class="product-form"
    data-hide-errors="{{ gift_card_recipient_feature_active }}"
    data-section-id="{{ section.id }}"
  >
    <div class="product-form__error-message-wrapper" role="alert" hidden>
      {%- render 'icon', icon: 'error-red' -%}
      <span class="product-form__error-message"></span>
    </div>
    
    {%- form 'product',
      product,
      id: product_form_id,
      class: 'form',
      novalidate: 'novalidate',
      data-type: 'add-to-cart-form'
    -%}
      <input
        type="hidden"
        name="id"
        value="{{ product.selected_or_first_available_variant.id }}"
        {% if product.selected_or_first_available_variant.available == false
          or quantity_rule_soldout
          or product.selected_or_first_available_variant == null
        %}
          disabled="disabled"
        {% endif %}
        class="product-variant-id"
      >
      {%- if gift_card_recipient_feature_active -%}
        {%- render 'gift-card-recipient-form', product: product, form: form, section: section -%}
      {%- endif -%}
      
      {%- comment -%} Monogram Feature {%- endcomment -%}
      {%- if block.settings.enable_monogram and block.settings.monogram_product != blank -%}
        {%- assign monogram_product = all_products[block.settings.monogram_product] -%}
        {%- if monogram_product != blank -%}
          {%- assign monogram_variant = monogram_product.selected_or_first_available_variant -%}
          {%- if monogram_variant.available -%}
            <div
              class="monogram-wrapper-{{ section.id }}"
              data-form-id="{{ product_form_id }}"
              data-section-id="{{ section.id }}"
              data-monogram-price="{{ monogram_variant.price }}"
            >
              {%- comment -%} ========== STEP 1: TRIGGER BUTTON ========== {%- endcomment -%}
              <div class="monogram-trigger-wrapper">
                <button type="button" class="monogram-trigger-btn" id="monogram-toggle-{{ section.id }}">
                  <span class="monogram-trigger-content">
                    <span class="monogram-trigger-label">Add Monogram</span>
                  </span>
                </button>
              </div>
              
{%- comment -%} Monogram summary removed from here {%- endcomment -%}

              {%- comment -%} ========== STEP 2: SELECTION POPUP (Choose which items to monogram) ========== {%- endcomment -%}
              <div class="monogram-modal-overlay" id="monogram-selection-overlay-{{ section.id }}" style="display: none;">
                <div class="monogram-modal monogram-selection-modal">
                  <div class="monogram-modal-header">
                    <div class="monogram-header-title-group">
                      <h3 class="monogram-modal-title">Add Monogram</h3>
                      <p class="monogram-processing-notice">Please note Monogrammed items take an additional 4-6 business days for processing.</p>
                    </div>
                    <button type="button" class="monogram-modal-close" id="monogram-selection-close-{{ section.id }}">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                      </svg>
                    </button>
                  </div>
                  <div class="monogram-modal-body">

                    <p class="monogram-selection-subtitle">Select a blanket to add monogram. Each blanket can have its own custom message.</p>
                    <div class="monogram-selection-grid" id="monogram-selection-grid-{{ section.id }}">
                      {%- comment -%} Selection boxes will be dynamically generated here {%- endcomment -%}
                    </div>
                  </div>
                  <div class="monogram-modal-footer monogram-selection-footer" style="display: none;">
                    <div class="monogram-terms-container">
                      <label class="monogram-terms-label">
                        <input type="checkbox" id="pod-terms-{{ section.id }}" class="pod-terms-checkbox-{{ section.id }}">
                        <span class="monogram-terms-text">I have double checked all of my information and understand monogram items are not eligible for return or exchange.</span>
                      </label>
                    </div>
                    <div class="monogram-selection-total" id="monogram-selection-total-{{ section.id }}">
                      Total: <span class="monogram-selection-total-value">0,00 kr</span>
                    </div>
                    <button type="button" class="monogram-save-btn monogram-selection-done-btn" id="monogram-selection-done-{{ section.id }}">
                      Done
                    </button>
                  </div>
                </div>
              </div>

              {%- comment -%} ========== STEP 3: DETAIL POPUP (Configure the monogram) ========== {%- endcomment -%}
              <div class="monogram-modal-overlay" id="monogram-detail-overlay-{{ section.id }}" style="display: none;">
                <div class="monogram-modal monogram-detail-modal">
                  <div class="monogram-modal-header">
                    <button type="button" class="monogram-modal-back" id="monogram-detail-back-{{ section.id }}">
                      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 18 9 12 15 6"></polyline>
                      </svg>
                      Back
                    </button>
                    <button type="button" class="monogram-modal-close" id="monogram-detail-close-{{ section.id }}">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                      </svg>
                    </button>
                  </div>
                  <div class="monogram-modal-body">
                    <div class="monogram-detail-content" id="monogram-detail-content-{{ section.id }}">
                      {%- comment -%} Detail form will be dynamically populated here {%- endcomment -%}
                    </div>
                  </div>
                  <div class="monogram-modal-footer">
                    <div class="monogram-detail-total" id="monogram-detail-total-{{ section.id }}">
                      Price: <span class="monogram-detail-total-value">0,00 kr</span>
                    </div>
                    <div class="monogram-modal-footer-btns">
                      <button type="button" class="monogram-remove-btn" id="monogram-remove-{{ section.id }}" style="display: none;">
                        Remove Monogram
                      </button>
                      <button type="button" class="monogram-save-btn" id="monogram-save-{{ section.id }}">
                        Save Monogram
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              {%- comment -%} Hidden container for monogram data (used by JS logic) {%- endcomment -%}
              <div class="monogram-box" id="monogram-box-{{ section.id }}" style="display: none;">
                <div class="monogram-items-container" id="monogram-items-container-{{ section.id }}"></div>
                <div class="monogramTotal" id="monogram-total-price-{{ section.id }}" style="display: none;">
                  <strong>Total: <span class="monogram-total-price-value"></span></strong>
                </div>
              </div>

              {%- comment -%} Template for single monogram item (hidden, used as template) {%- endcomment -%}
              <div id="monogram-item-template-{{ section.id }}" style="display: none !important;">
                <div class="monogram-item" data-item-index="">
                  <div class="monogram-content-wrapper">
                    <div class="monogram-image-container monogram-image-container-item">
                      {%- assign current_variant = product.selected_or_first_available_variant -%}
                      {%- assign variant_images = current_variant.metafields.custom.variant_monogram_images -%}
                      {%- assign product_images = product.metafields.custom.monogram_images -%}
                      
                      {%- if variant_images != blank and variant_images.value.size > 0 -%}
                        {%- for img in variant_images.value -%}
                          <img
                            class="monogram-base-image"
                            data-variant-id="{{ current_variant.id }}"
                            data-image-source="variant"
                            src="{{ img | image_url: width: 600 }}"
                            alt="{{ product.title }} - {{ current_variant.title }}"
                            loading="lazy"
                            width="600"
                            height="600"
                            style="display: none;"
                          >
                        {%- endfor -%}
                      {%- elsif product_images != blank and product_images.value.size > 0 -%}
                        {%- assign monogram_colors = product.metafields.custom.monogram_colors1.value -%}
                        {%- for img in product_images.value -%}
                          {%- assign color_index = forloop.index0 -%}
                          {%- if monogram_colors[color_index] != blank -%}
                            {%- assign image_color = monogram_colors[color_index] -%}
                          {%- else -%}
                            {%- assign image_color = 'default' -%}
                          {%- endif -%}
                          <img
                            class="monogram-base-image"
                            data-color="{{ image_color | escape }}"
                            data-color-index="{{ color_index }}"
                            data-image-source="product"
                            src="{{ img | image_url: width: 600 }}"
                            alt="{{ product.title }} - {{ image_color }}"
                            loading="lazy"
                            width="600"
                            height="600"
                            style="display: none;"
                          >
                        {%- endfor -%}
                      {%- else -%}
                        <img
                          class="monogram-base-image"
                          data-color="default"
                          data-image-source="fallback"
                          src="{{ product.featured_image | image_url: width: 600 }}"
                          alt="{{ product.title }}"
                          loading="lazy"
                          width="600"
                          height="600"
                          style="display: none;"
                        >
                      {%- endif -%}
                      <span class="monogram-preview-text monogram-preview-text-item"></span>
                    </div>

                    <div class="monogram-options-panel">
                      <div class="monogram-item-header">
                        <h4 class="monogram-item-title">MONOGRAM <span class="monogram-item-number">1</span></h4>
                      </div>

                      <label class="monogram-label-item">FONT STYLE</label>
                      <select class="monogram-style-select monogram-style-select-item">
                        <option value="">Choose a style</option>
                        {%- if shop.metaobjects.monogram_fonts.values != blank -%}
                          {%- for font in shop.metaobjects.monogram_fonts.values -%}
                            {%- assign font_display_name = font.font_name.value -%}
                            {%- if font_display_name == 'Playfair Display' -%}{%- assign font_display_name = 'Classic Serif' -%}{%- elsif font_display_name == 'Pinyon Script' -%}{%- assign font_display_name = 'Elegant Script' -%}{%- endif -%}
                            <option value="{{ font.font_name.value }}" data-url="{{ font.font_url1.value }}">
                              {{ font_display_name }}
                            </option>
                          {%- endfor -%}
                        {%- endif -%}
                      </select>

                      <label class="monogram-label-item">TEXT COLOR</label>
                      <select class="monogram-color-select monogram-color-select-item">
                        <option value="">Choose a color</option>
                        <option value="Black">Black</option>
                        <option value="White">White</option>
                      </select>

                      <label class="monogram-label-item">MONOGRAM TEXT</label>
                      <input
                        type="text"
                        class="monogram-text-input monogram-text-input-item"
                        name="monogram_text"
                        maxlength="10"
                        placeholder="Enter text (max 10 cha"
                      >
                    </div>
                  </div>
                </div>
              </div>
            </div>
            {%- endif -%}
          {%- endif -%}
        {%- endif -%}
      
      <div class="product-form__buttons{% if product.quantity_price_breaks_configured? %} with--price-break{% endif %}">
        {%- liquid
          assign check_against_inventory = true
          if product.selected_or_first_available_variant.inventory_management != 'shopify' or product.selected_or_first_available_variant.inventory_policy == 'continue'
            assign check_against_inventory = false
          endif
          if product.selected_or_first_available_variant.quantity_rule.min > product.selected_or_first_available_variant.inventory_quantity and check_against_inventory
            assign quantity_rule_soldout = true
          endif
        -%}
        {%- if block.settings.show_quantity_selector -%}
          <div id="Quantity-Form-{{ section.id }}" class="product-form__quantity">
            {% comment %} TODO: enable theme-check once `item_count_for_variant` is accepted as valid filter {% endcomment %}
            {% # theme-check-disable %}
            {%- assign cart_qty = cart
              | item_count_for_variant: product.selected_or_first_available_variant.id
            -%}
            {% # theme-check-enable %}
            <label for="Quantity-{{ section_id }}" class="visually-hidden">
              {{ 'products.product.quantity.label' | t }}
              <span class="quantity__rules-cart{% if cart_qty == 0 %} hidden{% endif %}">
                {%- render 'loading-spinner' -%}
                <span
                  >(
                  {{- 'products.product.quantity.in_cart_html' | t: quantity: cart_qty -}}
                  )</span
                >
              </span>
            </label>

            <div class="price-per-item__container">
              <quantity-input class="quantity" data-url="{{ product.url }}" data-block="{{ block.id }}" data-section="{{ section_id }}">
                <button class="quantity__button" name="minus" type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.decrease' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon', icon: 'minus' %}
                </button>
                <input
                  class="quantity__input quantity__input-primary"
                  type="number"
                  name="quantity"
                  id="Quantity-{{ section_id }}"
                  data-cart-quantity="{{ cart_qty }}"
                  data-min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  min="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  {% if product.selected_or_first_available_variant.quantity_rule.max != null %}
                    data-max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                    max="{{ product.selected_or_first_available_variant.quantity_rule.max }}"
                  {% endif %}
                  step="{{ product.selected_or_first_available_variant.quantity_rule.increment }}"
                  value="{{ product.selected_or_first_available_variant.quantity_rule.min }}"
                  form="{{ product_form_id }}"
                >
                <button class="quantity__button" name="plus" type="button">
                  <span class="visually-hidden">
                    {{- 'products.product.quantity.increase' | t: product: product.title | escape -}}
                  </span>
                  {% render 'icon', icon: 'plus' %}
                </button>
              </quantity-input>
              {%- liquid
                assign volume_pricing_array = product.selected_or_first_available_variant.quantity_price_breaks | sort: 'quantity' | reverse
                assign current_qty_for_volume_pricing = cart_qty | plus: product.selected_or_first_available_variant.quantity_rule.min
                if cart_qty > 0
                  assign current_qty_for_volume_pricing = cart_qty | plus: product.selected_or_first_available_variant.quantity_rule.increment
                endif
              -%}
              {%- if product.quantity_price_breaks_configured? -%}
                <price-per-item
                  id="Price-Per-Item-{{ section.id }}"
                  data-section-id="{{ section.id }}"
                  data-variant-id="{{ product.selected_or_first_available_variant.id }}"
                >
                  {%- if product.selected_or_first_available_variant.quantity_price_breaks.size > 0 -%}
                    {%- assign variant_price_compare = product.selected_or_first_available_variant.compare_at_price -%}
                    <div class="price-per-item">
                      {%- if variant_price_compare -%}
                        <dl class="price-per-item--current">
                          <dt class="visually-hidden">
                            {{ 'products.product.price.regular_price' | t }}
                          </dt>
                          <dd>
                            <s class="variant-item__old-price">
                              {{ variant_price_compare | money_with_currency }}
                            </s>
                          </dd>
                        </dl>
                      {%- endif -%}
                      {%- if current_qty_for_volume_pricing < volume_pricing_array.last.minimum_quantity -%}
                        {%- assign variant_price = product.selected_or_first_available_variant.price
                          | money_with_currency
                        -%}
                        <span class="price-per-item--current">
                          {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                        </span>
                      {%- else -%}
                        {%- for price_break in volume_pricing_array -%}
                          {%- if current_qty_for_volume_pricing >= price_break.minimum_quantity -%}
                            {%- assign price_break_price = price_break.price | money_with_currency -%}
                            <span class="price-per-item--current">
                              {{-
                                'products.product.volume_pricing.price_at_each'
                                | t: price: price_break_price
                              -}}
                            </span>
                            {%- break -%}
                          {%- endif -%}
                        {%- endfor -%}
                      {%- endif -%}
                    </div>
                  {%- else -%}
                    {%- assign variant_price = product.selected_or_first_available_variant.price
                      | money_with_currency
                    -%}
                    {%- assign variant_price_compare = product.selected_or_first_available_variant.compare_at_price -%}
                    <div class="price-per-item">
                      {%- if variant_price_compare -%}
                        <dl class="price-per-item--current">
                          <dt class="visually-hidden">
                            {{ 'products.product.price.regular_price' | t }}
                          </dt>
                          <dd>
                            <s class="variant-item__old-price">
                              {{ variant_price_compare | money_with_currency }}
                            </s>
                          </dd>
                          <dt class="visually-hidden">
                            {{ 'products.product.price.sale_price' | t }}
                          </dt>
                          <dd>
                            <span class="price-per-item--current">
                              {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                            </span>
                          </dd>
                        </dl>
                      {%- else -%}
                        <span class="price-per-item--current">
                          {{- 'products.product.volume_pricing.price_at_each' | t: price: variant_price -}}
                        </span>
                      {%- endif -%}
                    </div>
                  {%- endif -%}
                </price-per-item>
              {%- endif -%}
            </div>
            <div class="quantity__rules caption" id="Quantity-Rules-{{ section.id }}">
              {%- if product.selected_or_first_available_variant.quantity_rule.increment > 1 -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.multiples_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.increment
                  -}}
                </span>
              {%- endif -%}
              {%- if product.selected_or_first_available_variant.quantity_rule.min > 1 -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.minimum_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.min
                  -}}
                </span>
              {%- endif -%}
              {%- if product.selected_or_first_available_variant.quantity_rule.max != null -%}
                <span class="divider">
                  {{-
                    'products.product.quantity.maximum_of'
                    | t: quantity: product.selected_or_first_available_variant.quantity_rule.max
                  -}}
                </span>
              {%- endif -%}
            </div>
            {%- if product.quantity_price_breaks_configured? -%}
              <volume-pricing class="parent-display" id="Volume-{{ section.id }}">
                {%- if product.selected_or_first_available_variant.quantity_price_breaks.size > 0 -%}
                  <span class="caption-large">{{ 'products.product.volume_pricing.title' | t }}</span>
                  <ul class="list-unstyled">
                    <li>
                      <span>{{ product.selected_or_first_available_variant.quantity_rule.min }}+</span>
                      {%- assign price = product.selected_or_first_available_variant.price
                        | money_with_currency
                      -%}
                      <span data-text="{{ 'products.product.volume_pricing.price_at_each' | t: price: variant_price }}">
                        {{- 'sections.quick_order_list.each' | t: money: price -}}
                      </span>
                    </li>
                    {%- for price_break in product.selected_or_first_available_variant.quantity_price_breaks -%}
                      {%- assign price_break_price = price_break.price | money_with_currency -%}
                      <li class="{%- if forloop.index >= 3 -%}show-more-item hidden{%- endif -%}">
                        <span>
                          {{- price_break.minimum_quantity -}}
                          <span aria-hidden="true">+</span></span
                        >
                        <span data-text="{{ 'products.product.volume_pricing.price_at_each' | t: price: price_break_price }}">
                          {{- 'sections.quick_order_list.each' | t: money: price_break_price -}}
                        </span>
                      </li>
                    {%- endfor -%}
                  </ul>
                  {%- if product.selected_or_first_available_variant.quantity_price_breaks.size >= 3 -%}
                    <vp-show-more-button>
                      <button
                        class="button-show-more link underlined-link"
                        id="Show-More-{{ section.id }}"
                        type="button"
                      >
                        <span class="label-show-more label-text"
                          ><span aria-hidden="true">+ </span>{{ 'products.facets.show_more' | t }}
                        </span>
                      </button>
                    </vp-show-more-button>
                  {%- endif -%}
                {%- endif -%}
              </volume-pricing>
            {%- endif -%}
          </div>
        {%- endif -%}
        <button
          id="ProductSubmitButton-{{ section_id }}"
          type="submit"
          name="add"
          class="product-form__submit button{% if show_dynamic_checkout %} button--secondary{% endif %} button--full-width"
          {%- if product.selected_or_first_available_variant.available == false or quantity_rule_soldout
            or product.selected_or_first_available_variant == null %} disabled="disabled"{% endif -%}
          {%- if product.template_suffix == 'pre-order' %} data-pre-order="true"{% endif -%}
        >
          <span>
            {%- if product.selected_or_first_available_variant == null -%}
              {{ 'products.product.unavailable' | t }}
            {%- elsif product.selected_or_first_available_variant.available == false or quantity_rule_soldout -%}
              {{ 'products.product.sold_out' | t }}
            {%- else -%}
              {%- liquid
                if product.template_suffix != 'pre-order'
                  echo 'products.product.add_to_cart' | t
                else
                  echo 'products.product.pre_order' | t
                endif
              -%}
            {%- endif -%}
          </span>
        </button>
        {%- if show_dynamic_checkout -%}
          {{ form | payment_button }}
        {%- endif -%}
      </div>
    {%- endform -%}
  </product-form>
{%- else -%}
  <div class="product-form">
    <div class="product-form__buttons form">
      <button
        type="submit"
        name="add"
        class="product-form__submit button button--full-width button--primary"
        disabled
      >
        {{ 'products.product.sold_out' | t }}
      </button>
    </div>
  </div>
{%- endif -%}

{%- if show_pickup_availability -%}
  {{ 'component-pickup-availability.css' | asset_url | stylesheet_tag }}
  {%- assign pick_up_availabilities = product.selected_or_first_available_variant.store_availabilities | where: 'pick_up_enabled', true -%}
  <pickup-availability class="product__pickup-availabilities no-js-hidden"
    {% if product.selected_or_first_available_variant.available and pick_up_availabilities.size > 0 %} available{% endif %}
    data-root-url="{{ routes.root_url }}"
    data-variant-id="{{ product.selected_or_first_available_variant.id }}"
    data-has-only-default-variant="{{ product.has_only_default_variant }}"
  >
    <template>
      <pickup-availability-preview class="pickup-availability-preview">
        {% render 'icon', icon: 'unavailable' %}
        <div class="pickup-availability-info">
          <p class="caption-large">{{ 'products.product.pickup_availability.unavailable' | t }}</p>
          <button class="pickup-availability-button link link--underline">{{ 'products.product.pickup_availability.refresh' | t }}</button>
        </div>
      </pickup-availability-preview>
    </template>
  </pickup-availability>
  <script src="{{ 'pickup-availability.js' | asset_url }}" defer="defer"></script>
{%- endif -%}

{%- comment -%} Monogram Styles and Scripts {%- endcomment -%}
{%- if block.settings.enable_monogram and block.settings.monogram_product != blank -%}
  {%- assign monogram_product_check = all_products[block.settings.monogram_product] -%}
  {%- if monogram_product_check != blank -%}
    {%- assign monogram_variant_check = monogram_product_check.selected_or_first_available_variant -%}
    {%- if monogram_variant_check.available -%}
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Playfair+Display:wght@400&display=swap" rel="stylesheet">
      <style>
        /* ========== CORE / UTILITY ========== */
        .product-form__submit.monogram-disabled {
          pointer-events: none;
          opacity: 0.7;
        }
        .monogram-wrapper-{{ section.id }} {
          margin-bottom: 15px;
        }
        .monogram-box {
          display: none !important;
        }

        /* ========== STEP 1: TRIGGER BUTTON ========== */
        .monogram-trigger-wrapper {
          display: flex;
          gap: 10px;
          align-items: stretch;
          margin-bottom: 20px;
        }

        .monogram-trigger-btn {
          flex: 1;
          padding: 12px 24px;
          background: #f6f3ee;
          border: 1px solid #000;
          color: #000;
          font-family: var(--font-body-family);
          font-weight: 600;
          font-size: 16px;
          cursor: pointer;
          text-transform: uppercase;
          letter-spacing: 1px;
          border-radius: 8px;
          transition: all 0.3s ease;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
          text-align: center;
        }

        .monogram-trigger-btn:before {
          border: 1px solid #000;
          content: "";
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          width: calc(100% - 6px);
          height: calc(100% - 6px);
          border-radius: 6px;
          pointer-events: none;
        }

        .monogram-trigger-btn:hover {
          background: #efece6;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .monogram-remove-all-btn {
          display: none;
        }
        .monogram-trigger-content {
          display: flex;
          flex-direction: column;
          gap: 2px;
        }
        .monogram-trigger-label {
          font-size: 16px;
          font-weight: 600;
          color: #000;
          line-height: 1;
        }
        .monogram-trigger-price {
          font-size: 13px;
          color: #666;
          line-height: 1.3;
        }

        /* ========== MODAL OVERLAY ========== */
        .monogram-modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.5);
          z-index: 9999;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
          animation: monogramFadeIn 0.2s ease;
        }
        @keyframes monogramFadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        .monogram-modal {
          background: #fff;
          border-radius: 12px;
          max-width: 600px;
          width: 100%;
          max-height: 90vh;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          animation: monogramSlideUp 0.25s ease;
          box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        }
        @keyframes monogramSlideUp {
          from { 
            opacity: 0;
            transform: translateY(20px);
          }
          to { 
            opacity: 1;
            transform: translateY(0);
          }
        }
        .monogram-detail-modal {
          max-width: 700px;
        }

        /* ========== MODAL HEADER ========== */
        .monogram-modal-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid #eee;
        }
        .monogram-modal-title {
          font-size: 18px;
          font-weight: 600;
          margin: 0;
          color: #000;
          line-height: 1.2;
        }
        .monogram-processing-notice {
          font-size: 11px;
          color: #cc0000;
          margin: 4px 0 0 0;
          font-weight: 500;
          line-height: 1.3;
        }
        .monogram-header-title-group {
          flex: 1;
        }
        .monogram-modal-close {
          background: none;
          border: none;
          cursor: pointer;
          padding: 4px;
          color: #666;
          transition: color 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .monogram-modal-close:hover {
          color: #000;
        }
        .monogram-modal-back {
          display: flex;
          align-items: center;
          gap: 4px;
          background: none;
          border: none;
          cursor: pointer;
          padding: 4px 8px;
          margin-left: -8px;
          color: #666;
          font-size: 14px;
          font-family: var(--font-body-family);
          transition: color 0.2s ease;
        }
        .monogram-modal-back:hover {
          color: #000;
        }

        /* ========== MODAL BODY ========== */
        .monogram-modal-body {
          padding: 20px;
          overflow-y: auto;
          flex: 1;
          -webkit-overflow-scrolling: touch;
        }
        .monogram-notice {
          background: #FFFBF2;
          border: 1px solid #E6B56E;
          padding: 16px 20px;
          margin-bottom: 24px;
          border-radius: 12px;
        }
        .monogram-notice p {
          font-size: 13px;
          line-height: 1.6;
          color: #856404;
          margin: 0;
        }
        .monogram-notice strong {
          color: #856404;
        }
        .monogram-item-add-icon {
          display: none;
        }
        .monogram-selection-subtitle {
          font-size: 14px;
          color: #666;
          margin: 0 0 20px 0;
          text-align: center;
        }

        /* ========== SELECTION GRID (Step 2) ========== */
        .monogram-selection-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
        }
        .monogram-selection-item {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 20px 16px;
          background: #fff;
          border: 2px solid #e5e5e5;
          border-radius: 8px;
          cursor: pointer;
          text-align: center;
          transition: all 0.2s ease;
          min-height: 100px;
        }
        .monogram-selection-item:hover {
          border-color: #333;
        }
        .monogram-selection-item.is-completed {
          border-color: #22c55e;
          background: #f0fdf4;
        }
        .monogram-item-remove-badge {
          position: absolute;
          top: 8px;
          right: 8px;
          width: 24px;
          height: 24px;
          background: #ef4444;
          color: #fff;
          border: none;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          z-index: 5;
          transition: all 0.2s ease;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .monogram-item-remove-badge:hover {
          background: #dc2626;
          transform: scale(1.1);
        }
        .monogram-item-remove-badge svg {
          width: 14px;
          height: 14px;
        }
        .monogram-selection-item {
          position: relative;
        }
        .monogram-selection-label {
          font-size: 14px;
          color: #000;
          line-height: 1.4;
          margin-bottom: 4px;
        }
        .monogram-selection-label strong {
          font-weight: 600;
        }
        .monogram-selection-price {
          font-size: 13px;
          color: #666;
        }

        /* ========== DETAIL CONTENT (Step 3) ========== */
        .monogram-detail-content {
          display: flex;
          gap: 24px;
        }
        .monogram-detail-image-wrap {
          flex: 0 0 280px;
          max-width: 280px;
        }
        .monogram-detail-image-container {
          position: relative;
          background: #f5f5f5;
          border-radius: 8px;
          overflow: hidden;
          aspect-ratio: 1;
        }
        .monogram-detail-image-container .monogram-base-image {
          width: 100%;
          height: 100%;
          object-fit: cover;
        }
        .monogram-detail-form {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 0;
        }
        .monogram-detail-title {
          font-size: 16px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          margin: 0 0 20px 0;
          color: #000;
        }
        .monogram-detail-form .monogram-label-item {
          display: block;
          font-size: 12px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          color: #000;
          margin-bottom: 6px;
          margin-top: 16px;
        }
        .monogram-detail-form .monogram-label-item:first-of-type {
          margin-top: 0;
        }
        .monogram-detail-form .monogram-style-select,
        .monogram-detail-form .monogram-color-select,
        .monogram-detail-form .monogram-text-input {
          width: 100%;
          padding: 12px 14px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
          font-family: var(--font-body-family);
          background: #fff;
          transition: border-color 0.2s ease;
        }
        .monogram-detail-form .monogram-style-select:focus,
        .monogram-detail-form .monogram-color-select:focus,
        .monogram-detail-form .monogram-text-input:focus {
          outline: none;
          border-color: #000;
        }
        .monogram-preview-text {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 20px;
          font-weight: 400;
          user-select: none;
          white-space: nowrap;
          cursor: default;
          z-index: 10;
          color: #000;
          text-transform: none;
          pointer-events: none;
        }

        /* ========== MODAL FOOTER ========== */
        .monogram-modal-footer {
          padding: 15px 20px;
          border-top: 1px solid #eee;
          display: flex;
          flex-direction: column;
          gap: 0px;
        }
        .monogram-selection-footer {
          padding-top: 20px;
        }
        .monogram-selection-total,
        .monogram-detail-total {
          text-align: center;
          font-size: 16px;
          font-weight: 600;
          color: #000;
          margin-bottom: 5px;
        }
        .monogram-terms-container {
          margin-bottom: 5px;
        }
        .monogram-terms-label {
          display: flex;
          align-items: flex-start;
          gap: 10px;
          cursor: pointer;
          font-size: 13px;
          line-height: 1.4;
          color: #444;
        }
        .monogram-terms-label input[type="checkbox"] {
          margin-top: 2px;
          flex-shrink: 0;
          width: 18px;
          height: 18px;
          cursor: pointer;
          accent-color: #000;
        }
        .monogram-modal-footer-btns {
          display: flex;
          gap: 12px;
          width: 100%;
        }
        .monogram-save-btn {
          flex: 2;
          padding: 14px 24px;
          background: #000;
          color: #fff;
          border: none;
          border-radius: 6px;
          font-size: 14px;
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-family: var(--font-body-family);
        }
        .monogram-remove-btn {
          flex: 1;
          padding: 14px 12px;
          background: #fff;
          color: #cc0000;
          border: 1px solid #cc0000;
          border-radius: 6px;
          font-size: 13px;
          font-weight: 600;
          text-transform: uppercase;
          letter-spacing: 0.5px;
          cursor: pointer;
          transition: all 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          font-family: var(--font-body-family);
        }
        .monogram-remove-btn:hover {
          background: #fff0f0;
        }
        .monogram-save-btn:hover:not(:disabled) {
          background: #333;
        }
        .monogram-save-btn:disabled {
          background: #ccc;
          cursor: not-allowed;
          opacity: 0.7;
        }
        .monogram-selection-done-btn {
          width: 100%;
          margin-top: 5px;
        }

        /* ========== ACTIVE BADGE FOR TRIGGER ========== */
        .monogram-trigger-btn.has-monograms {
          /* Inherit base styles to stay consistent */
        }
        .monogram-active-count {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          background: #22c55e;
          color: #fff;
          font-size: 11px;
          font-weight: 600;
          padding: 2px 8px;
          border-radius: 10px;
          margin-left: 8px;
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 640px) {
          .monogram-modal-overlay {
            padding: 16px;
            align-items: center;
          }
          .monogram-modal {
            max-height: 85vh;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
          }
          .monogram-modal-header {
            padding: 14px 16px;
          }
          .monogram-modal-body {
            padding: 16px;
          }
          .monogram-notice {
            padding: 12px 14px;
            margin-bottom: 16px;
            gap: 10px;
            display: flex;
            align-items: flex-start;
          }
          .monogram-notice::before {
            content: 'i';
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: #E6B56E;
            color: #fff;
            border-radius: 50%;
            font-family: serif;
            font-style: italic;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
            margin-top: 2px;
          }
          .monogram-notice p {
            font-size: 12px;
            line-height: 1.5;
          }
          .monogram-selection-subtitle {
            margin-bottom: 16px;
            font-size: 13px;
          }
          .monogram-selection-grid {
            grid-template-columns: 1fr;
            gap: 10px;
          }
          .monogram-selection-item {
            flex-direction: row;
            justify-content: flex-start;
            padding: 14px 16px;
            min-height: auto;
            text-align: left;
            gap: 12px;
          }
          .monogram-selection-label {
            margin-bottom: 0;
            flex-grow: 1;
            font-size: 14px;
          }
          .monogram-selection-price {
            font-weight: 500;
          }
          .monogram-item-add-icon {
             display: flex;
             align-items: center;
             justify-content: center;
             width: 24px;
             height: 24px;
             background: #f5f5f5;
             border-radius: 50%;
             color: #666;
             flex-shrink: 0;
          }
          .monogram-selection-item.is-completed .monogram-item-add-icon {
            background: #22c55e;
            color: #fff;
          }
          .monogram-detail-content {
            flex-direction: column;
            gap: 20px;
          }
          .monogram-detail-image-container {
            max-width: 100%;
          }
          .monogram-detail-title {
            font-size: 14px;
            margin-bottom: 12px;
          }
          .monogram-modal-footer {
            padding: 16px;
          }
          .monogram-modal-footer-btns {
            flex-direction: column-reverse;
          }
          .monogram-save-btn, .monogram-remove-btn {
            width: 100%;
          }
        }

        /* ========== TERMS CHECKBOX (In Modal) ========== */
        .monogram-terms-container {
          margin-bottom: 20px;
          padding: 0;
          background: none;
          border: none;
        }
        .monogram-terms-label {
          display: flex;
          align-items: flex-start;
          gap: 12px;
          cursor: pointer;
          color: #111;
          font-weight: 400;
        }
        .monogram-terms-text {
          font-size: 13px;
          line-height: 1.4;
          padding-top: 1px;
        }
        @media (max-width: 640px) {
          .monogram-terms-text {
            font-size: 11px;
            line-height: 1.3;
            padding-top: 0;
            color: #555;
          }
        }
        /* Custom large checkbox styling */
        .monogram-terms-label input[type="checkbox"] {
          appearance: none;
          -webkit-appearance: none;
          width: 28px;
          height: 28px;
          border: 1px solid #ccc;
          border-radius: 6px;
          background: #fff;
          cursor: pointer;
          position: relative;
          flex-shrink: 0;
          transition: all 0.2s ease;
        }
        @media (max-width: 640px) {
          .monogram-terms-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            border-radius: 4px;
          }
        }
        .monogram-terms-label input[type="checkbox"]:checked {
          background: #151515;
          border-color: #151515;
        }
        .monogram-terms-label input[type="checkbox"]:checked::after {
          content: '';
          position: absolute;
          left: 9px;
          top: 4px;
          width: 7px;
          height: 13px;
          border: solid #fff;
          border-width: 0 2px 2px 0;
          transform: rotate(45deg);
        }
        @media (max-width: 640px) {
          .monogram-terms-label input[type="checkbox"]:checked::after {
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
          }
        }

        /* ========== LEGACY COMPAT (hidden) ========== */
        .monogram-items-container,
        .monogramTotal,
        .monogram-item-template,
        #monogram-item-template-{{ section.id }} {
          display: none !important;
        }
      </style>

      <script>
      (function() {
        'use strict';
        const sectionId = '{{ section.id }}';
        const formId = '{{ product_form_id }}';
        const monogramProductId = {{ monogram_variant_check.id }};
        const mainProductId = {{ product.selected_or_first_available_variant.id }};
        
        document.addEventListener('DOMContentLoaded', function() {
          const wrapper = document.querySelector('.monogram-wrapper-{{ section.id }}');
          if (!wrapper) return;
          
          const toggleBtn = document.getElementById('monogram-toggle-{{ section.id }}');
          const monogramBox = document.getElementById('monogram-box-{{ section.id }}');
          const monogramItemsContainer = document.getElementById('monogram-items-container-{{ section.id }}');
          const monogramItemTemplate = document.getElementById('monogram-item-template-{{ section.id }}');
          const checkboxTerms = document.getElementById('pod-terms-{{ section.id }}');
          const processingNotice = wrapper.querySelector('.monogram-processing-notice-wrapper');
          
          // NEW: Modal elements for 3-step popup flow
          const selectionOverlay = document.getElementById('monogram-selection-overlay-{{ section.id }}');
          const selectionCloseBtn = document.getElementById('monogram-selection-close-{{ section.id }}');
          const selectionGrid = document.getElementById('monogram-selection-grid-{{ section.id }}');
          const detailOverlay = document.getElementById('monogram-detail-overlay-{{ section.id }}');
          const detailBackBtn = document.getElementById('monogram-detail-back-{{ section.id }}');
          const detailCloseBtn = document.getElementById('monogram-detail-close-{{ section.id }}');
          const detailContent = document.getElementById('monogram-detail-content-{{ section.id }}');
          const saveBtn = document.getElementById('monogram-save-{{ section.id }}');
          const selectionDoneBtn = document.getElementById('monogram-selection-done-{{ section.id }}');
          const removeBtn = document.getElementById('monogram-remove-{{ section.id }}');
          const removeAllBtn = document.getElementById('monogram-remove-all-{{ section.id }}');
          
          // Track current editing state
          let currentEditingIndex = -1;
          let monogramCompletedItems = {}; // Track which items have been completed
          
          // Get ATC button with fallback selectors
          const atcButton = document.querySelector('#ProductSubmitButton-{{ section_id }}') || 
                           document.querySelector('#ProductSubmitButton-{{ section.id }}') ||
                           wrapper?.closest('product-form')?.querySelector('button[type="submit"][name="add"]') ||
                           document.querySelector('button[type="submit"][name="add"]');
          const productFormElement = wrapper.closest('product-form');
          
          // Debug: Check if elements exist
          if (!toggleBtn) {
            console.error('[Monogram] Toggle button not found:', 'monogram-toggle-{{ section.id }}');
          }
          if (!monogramBox) {
            console.error('[Monogram] Monogram box not found:', 'monogram-box-{{ section.id }}');
          }

          let monogramItemsData = [];
          let currentBundleItemCount = 1;
          let isMonogramBoxOpen = false;
          // Base price in cents (from original currency, will be converted dynamically)
          const monogramBasePrice = {{ monogram_variant_check.price }};
          
          // Get current monogram price in current currency
          function getMonogramUnitPrice() {
            // Try to get updated price from data attribute (updated by currency switcher)
            if (wrapper) {
              const dataPrice = wrapper.getAttribute('data-monogram-price');
              if (dataPrice) {
                const price = parseInt(dataPrice);
                if (!isNaN(price) && price > 0) {
                  return price;
                }
              }
            }
            // Fallback to base price
            return monogramBasePrice;
          }
          
          // Format money using current currency settings
          function formatMoney(cents) {
            // Use theme's currency formatter with current currency settings
            if (typeof theme !== 'undefined' && theme.Currency && theme.Currency.formatMoney) {
              const moneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat 
                ? theme.shopSettings.moneyFormat 
                : '{{ shop.money_format | json }}';
              return theme.Currency.formatMoney(cents, moneyFormat);
            }
            // Fallback to Shopify's formatMoney
            if (typeof Shopify !== 'undefined' && Shopify.formatMoney) {
              const moneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat 
                ? theme.shopSettings.moneyFormat 
                : '{{ shop.money_format | json }}';
              return Shopify.formatMoney(cents, moneyFormat);
            }
            // Final fallback
            const dollars = (cents / 100).toFixed(2);
            return '$' + dollars;
          }
          
          // Check if any monogram text fields are empty (for completed items)
          function hasEmptyMonogramTextFields() {
            // In the new popup flow, we check if any completed items have empty text
            const completedCount = Object.values(monogramCompletedItems).filter(Boolean).length;
            if (completedCount === 0) {
              return false; // No monograms added, so no empty fields
            }
            
            // Check completed items for empty text
            for (let i = 0; i < monogramItemsData.length; i++) {
              if (monogramCompletedItems[i]) {
                const itemData = monogramItemsData[i];
                if (itemData && itemData.textInput && !itemData.textInput.value.trim()) {
                  return true;
                }
              }
            }
            return false;
          }
          
          // Update button disable state
          function updateATCButtonState() {
            if (!atcButton) return;
            
            // In new popup flow, check if user has added any monograms
            const completedCount = Object.values(monogramCompletedItems).filter(Boolean).length;
            const hasMonograms = completedCount > 0;
            const checkboxChecked = checkboxTerms && checkboxTerms.checked;
            const hasEmptyFields = hasEmptyMonogramTextFields();
            
            console.log('[Monogram] updateATCButtonState:', { hasMonograms, checkboxChecked, hasEmptyFields, completedCount });
            
            // Check if button was disabled by theme for product unavailability
            const hasDataUnavailable = atcButton.hasAttribute('data-unavailable') && atcButton.getAttribute('data-unavailable') === 'true';
            
            if (hasMonograms && (!checkboxChecked || hasEmptyFields)) {
              // User has added monograms but requirements not met - disable
              atcButton.classList.add('monogram-disabled');
              atcButton.disabled = true;
              console.log('[Monogram] Button disabled - checkbox:', checkboxChecked, 'emptyFields:', hasEmptyFields);
            } else if (!hasDataUnavailable) {
              // Requirements met OR no monograms added, and product is available - enable
              atcButton.classList.remove('monogram-disabled');
              atcButton.disabled = false;
              console.log('[Monogram] Button enabled');
            } else {
              // Product is unavailable - keep disabled but remove monogram-disabled class
              atcButton.classList.remove('monogram-disabled');
              console.log('[Monogram] Button kept disabled (product unavailable)');
            }
          }

          if (checkboxTerms) {
            checkboxTerms.addEventListener('change', function() {
              updateSelectionDoneButton();
              updateATCButtonState();
            });
          }

          let loadedFonts = {};
          const btnTextSpan = toggleBtn ? toggleBtn.querySelector('.monogram-btn-text') : null;
          const totalPriceDisplay = document.getElementById('monogram-total-price-{{ section.id }}');
          const totalPriceValue = totalPriceDisplay ? totalPriceDisplay.querySelector('.monogram-total-price-value') : null;
          
          // Count monograms with text (only completed items)
          function countMonogramsWithText() {
            let count = 0;
            for (let i = 0; i < monogramItemsData.length; i++) {
              if (monogramCompletedItems[i]) {
                const itemData = monogramItemsData[i];
                if (itemData && itemData.textInput && itemData.textInput.value.trim()) {
                  count++;
                }
              }
            }
            return count;
          }
          
          // Update button text (legacy - no longer used in new popup flow)
          function updateMonogramButton() {
            // This function is kept for compatibility but is no longer used
            // The trigger button state is now managed by updateTriggerButtonState()
          }
          
          // Update total price (for legacy hidden elements - kept for cart submission)
          function updateMonogramTotalPrice() {
            // Price is now shown inline on the trigger button and in the modals
            // This function updates the hidden total for cart calculation
            const completedCount = Object.values(monogramCompletedItems).filter(Boolean).length;
            const summaryValue = document.querySelector('.monogram-total-summary-value');
            const summaryCount = document.querySelector('.monogram-total-count');
            if (summaryValue) {
              const monogramUnitPrice = getMonogramUnitPrice();
              const totalPrice = monogramUnitPrice * completedCount;
              summaryValue.textContent = formatMoney(totalPrice);
            }
            if (summaryCount) {
              summaryCount.textContent = completedCount + (completedCount === 1 ? ' monogram' : ' monograms');
            }
            
            if (totalPriceDisplay && totalPriceValue) {
              const monogramUnitPrice = getMonogramUnitPrice();
              const totalPrice = monogramUnitPrice * completedCount;
              totalPriceValue.textContent = formatMoney(totalPrice);
            }
          }
          
          // Detect bundle selection
          function isBundleSelected() {
            return !!document.querySelector('.kaching-bundles__bar--selected');
          }
          
          function getSelectedBundleItemCount() {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return 1;
            
            // Method 1: Count variant selector wrappers (each item has color/size options)
            const variantSelectors = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (variantSelectors.length > 0) {
              console.log('[Monogram] Bundle item count from variant wrappers:', variantSelectors.length);
              return variantSelectors.length;
            }
            
            // Method 2: Try to get count from bundle title/name (e.g., "Buy 2, Get 2 Free" = 4 items)
            const bundleTitle = selectedBundle.querySelector('.kaching-bundles__bar-title, .kaching-bundles__bar-deal-name, [class*="title"]');
            if (bundleTitle) {
              const titleText = bundleTitle.textContent || '';
              console.log('[Monogram] Bundle title:', titleText);
              
              // Parse "Buy X, Get Y Free" pattern
              const buyGetMatch = titleText.match(/buy\s*(\d+).*get\s*(\d+)/i);
              if (buyGetMatch) {
                const buyCount = parseInt(buyGetMatch[1]) || 0;
                const getCount = parseInt(buyGetMatch[2]) || 0;
                const totalCount = buyCount + getCount;
                console.log('[Monogram] Parsed from title: Buy', buyCount, '+ Get', getCount, '=', totalCount, 'items');
                return totalCount;
              }
              
              // Parse simple number pattern (e.g., "4 Items Bundle")
              const numberMatch = titleText.match(/(\d+)/);
              if (numberMatch) {
                const count = parseInt(numberMatch[1]);
                if (count > 0 && count <= 10) {
                  console.log('[Monogram] Parsed count from title:', count);
                  return count;
                }
              }
            }
            
            // Method 3: Count items by looking for numbered elements (e.g., #1, #2, #3, #4)
            const numberedItems = selectedBundle.querySelectorAll('[class*="item-number"], [class*="item_number"], .kaching-bundles__bar-item');
            if (numberedItems.length > 0) {
              console.log('[Monogram] Bundle item count from numbered items:', numberedItems.length);
              return numberedItems.length;
            }
            
            // Method 4: Count color/variant dropdowns
            const colorSelects = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-select');
            if (colorSelects.length > 0) {
              // Usually 2 selects per item (color + size), so divide by 2
              const possibleCount = Math.ceil(colorSelects.length / 2);
              console.log('[Monogram] Bundle item count from selects:', possibleCount, '(from', colorSelects.length, 'selects)');
              return possibleCount;
            }
            
            console.log('[Monogram] Could not determine bundle item count, defaulting to 1');
            return 1;
          }
          
          // Generate monogram items
          function generateMonogramItems(itemCount) {
            if (!monogramItemsContainer || !monogramItemTemplate) return;
            
            monogramItemsContainer.innerHTML = '';
            monogramItemsData = [];
            
            const templateItem = monogramItemTemplate.querySelector('.monogram-item');
            if (!templateItem) return;
            
            // Get current variant ID to use correct images
            const productForm = document.getElementById(formId);
            let currentVariantId = mainProductId;
            if (productForm) {
              const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
              if (variantIdInput) {
                if (variantIdInput.tagName === 'SELECT') {
                  currentVariantId = variantIdInput.options[variantIdInput.selectedIndex]?.value || mainProductId;
                } else {
                  currentVariantId = variantIdInput.value || mainProductId;
                }
              }
            }
            currentVariantId = parseInt(currentVariantId);
            console.log('[Monogram] Generating', itemCount, 'monogram items for variant ID:', currentVariantId);
            
            for (let i = 0; i < itemCount; i++) {
              const itemClone = templateItem.cloneNode(true);
              const monogramItem = itemClone;
              
              monogramItem.dataset.itemIndex = i;
              
              const itemNumberSpan = monogramItem.querySelector('.monogram-item-number');
              if (itemNumberSpan) {
                itemNumberSpan.textContent = (i + 1);
              }
              
              const styleSelect = monogramItem.querySelector('.monogram-style-select-item');
              const colorSelect = monogramItem.querySelector('.monogram-color-select-item');
              const textInput = monogramItem.querySelector('.monogram-text-input-item');
              const previewText = monogramItem.querySelector('.monogram-preview-text-item');
              const imageContainer = monogramItem.querySelector('.monogram-image-container-item');
              
              // Update images for current variant if variant has images
              if (imageContainer && variantImagesData[currentVariantId] && variantImagesData[currentVariantId].images && variantImagesData[currentVariantId].images.length > 0) {
                console.log('[Monogram] Using variant-specific images for item', i);
                // Remove template images
                const existingImages = imageContainer.querySelectorAll('.monogram-base-image');
                existingImages.forEach(function(img) {
                  img.remove();
                });
                
                // Add variant-specific images
                const variantData = variantImagesData[currentVariantId];
                variantData.images.forEach(function(imgData, index) {
                  const newImg = document.createElement('img');
                  newImg.className = 'monogram-base-image';
                  newImg.setAttribute('data-variant-id', currentVariantId);
                  newImg.setAttribute('data-image-source', 'variant');
                  newImg.src = imgData.src;
                  newImg.alt = imgData.alt;
                  newImg.loading = 'lazy';
                  newImg.width = 600;
                  newImg.height = 600;
                  newImg.style.display = index === 0 ? 'block' : 'none';
                  
                  if (previewText) {
                    imageContainer.insertBefore(newImg, previewText);
                  } else {
                    imageContainer.appendChild(newImg);
                  }
                });
              } else {
                console.log('[Monogram] Using template images for item', i, '(will be updated after all items are created)');
              }
              
              const itemData = {
                index: i,
                styleSelect: styleSelect,
                colorSelect: colorSelect,
                textInput: textInput,
                previewText: previewText,
                imageContainer: imageContainer,
                position: { x: 50, y: 50 }
              };
              monogramItemsData.push(itemData);
              
              if (previewText) {
                previewText.style.position = 'absolute';
                previewText.style.top = '50%';
                previewText.style.left = '50%';
                previewText.style.transform = 'translate(-50%, -50%)';
                previewText.style.color = '#000000';
                previewText.style.display = 'block';
                previewText.style.zIndex = '10';
                previewText.style.fontSize = '22px';
                previewText.style.fontWeight = '400';
                previewText.style.textTransform = 'none';
                previewText.style.whiteSpace = 'nowrap';
                previewText.style.cursor = 'default';
                previewText.style.pointerEvents = 'none';
              }
              
              initMonogramItemInteractions(itemData);
              monogramItemsContainer.appendChild(monogramItem);
            }
            
            updateMonogramButton();
            updateMonogramTotalPrice();
            updateATCButtonState();
          }
          
          // Initialize monogram item interactions
          function initMonogramItemInteractions(itemData) {
            if (!itemData || !itemData.previewText || !itemData.imageContainer) return;
            
            function updateItemPreviewText() {
              const text = itemData.textInput ? itemData.textInput.value : '';
              itemData.previewText.textContent = text;
              
              if (itemData.colorSelect && itemData.colorSelect.value) {
                const color = itemData.colorSelect.value.toLowerCase();
                itemData.previewText.style.color = color;
              } else {
                itemData.previewText.style.color = '#000000';
              }
              
              if (itemData.styleSelect && itemData.styleSelect.value) {
                let fontName = itemData.styleSelect.value;
                const selectedOption = itemData.styleSelect.options[itemData.styleSelect.selectedIndex];
                const fontUrl = selectedOption ? selectedOption.dataset.url : null;
                
                // Logic to handle Google Fonts specifically and bypass potential broken Metaobject URLs
                const isPlayfair = fontName.toLowerCase().includes('playfair');
                const isPinyon = fontName.toLowerCase().includes('pinyon');
                
                if (isPlayfair) {
                  itemData.previewText.style.fontFamily = '"Playfair Display", serif';
                  console.log('[Monogram] Applied Playfair Display via Google Fonts');
                } else if (isPinyon) {
                  itemData.previewText.style.fontFamily = '"Pinyon Script", cursive';
                  console.log('[Monogram] Applied Pinyon Script via Google Fonts');
                } else if (fontUrl && fontName) {
                  console.log('[Monogram] Loading custom font:', fontName, fontUrl);
                  loadFont(fontName, fontUrl).then(function() {
                    console.log('[Monogram] Custom font loaded successfully:', fontName);
                    itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                  }).catch(function(err) {
                    console.error('[Monogram] Custom font loading failed for:', fontName, err);
                    itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                  });
                } else {
                  itemData.previewText.style.fontFamily = '"' + fontName + '", serif';
                }
              } else {
                itemData.previewText.style.fontFamily = 'inherit';
              }
            }
            
            // Initial update
            updateItemPreviewText();
            
            if (itemData.textInput) {
              itemData.textInput.addEventListener('input', function() {
                updateItemPreviewText();
                updateMonogramTotalPrice();
                updateATCButtonState();
              });
            }
            
            if (itemData.colorSelect) {
              itemData.colorSelect.addEventListener('change', updateItemPreviewText);
            }
            
            if (itemData.styleSelect) {
              itemData.styleSelect.addEventListener('change', updateItemPreviewText);
            }
            
            // Sync image with bundle color (for bundle items)
            function syncImageWithBundleColor() {
              if (isBundleSelected()) {
                const bundleColor = getBundleColorForItem(itemData.index);
                if (bundleColor) {
                  updateSingleMonogramItemImage(itemData.index, bundleColor);
                }
              }
            }
            
            // Store sync function for external calls
            itemData.syncImageWithBundle = syncImageWithBundleColor;
            
            // Sync image with bundle color (for bundle items)
          }
          
          // Load font with fallback to Google Fonts
          function loadFont(fontName, fontUrl) {
            if (loadedFonts[fontName]) {
              console.log('[Monogram] Font already loaded:', fontName);
              return Promise.resolve();
            }
            
            // Fallback Google Fonts URLs if metafield URL is missing
            const googleFontUrls = {
              'Playfair Display': 'https://fonts.gstatic.com/s/playfairdisplay/v30/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgEM86xQ.woff2',
              'Pinyon Script': 'https://fonts.gstatic.com/s/pinyonscript/v17/6xKpdSJbL9-e9LuoeQiDRQR8WOXaPw.woff2'
            };
            
            const urlToUse = fontUrl || googleFontUrls[fontName];
            
            if (!urlToUse) {
              console.warn('[Monogram] No font URL available for:', fontName);
              return Promise.resolve();
            }
            
            console.log('[Monogram] Loading font:', fontName, 'from:', urlToUse);
            
            return new Promise(function(resolve, reject) {
              try {
                const fontFace = new FontFace(fontName, `url(${urlToUse})`);
                fontFace.load().then(function(loadedFace) {
                  document.fonts.add(loadedFace);
                  loadedFonts[fontName] = true;
                  console.log('[Monogram] Font loaded successfully:', fontName);
                  resolve();
                }).catch(function(err) {
                  console.error('[Monogram] Font load error for', fontName, ':', err);
                  // Try Google Font fallback if metafield URL failed
                  if (fontUrl && googleFontUrls[fontName]) {
                    console.log('[Monogram] Trying Google Fonts fallback for:', fontName);
                    const fallbackFace = new FontFace(fontName, `url(${googleFontUrls[fontName]})`);
                    fallbackFace.load().then(function(loadedFace) {
                      document.fonts.add(loadedFace);
                      loadedFonts[fontName] = true;
                      resolve();
                    }).catch(function() {
                      resolve(); // Continue even if font failed
                    });
                  } else {
                    resolve(); // Continue even if font failed
                  }
                });
              } catch (e) {
                console.error('[Monogram] Font Face API error:', e);
                resolve();
              }
            });
          }
          
          // Preload both fonts on page load for better UX
          function preloadMonogramFonts() {
            console.log('[Monogram] Preloading fonts...');
            loadFont('Playfair Display', '');
            loadFont('Pinyon Script', '');
          }
          
          // Preload fonts after a short delay (non-blocking)
          setTimeout(preloadMonogramFonts, 1000);
          
          // ========== NEW: POPUP MODAL FUNCTIONS ==========
          
          // Get bundle item info (color, size) for each item
          function getBundleItemsInfo() {
            const items = [];
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            
            if (selectedBundle) {
              const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
              variantWrappers.forEach(function(wrapper, index) {
                let color = '';
                let size = '';
                
                // Get color
                let colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
                if (!colorSelect) colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
                if (!colorSelect) colorSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
                if (colorSelect) color = colorSelect.value || colorSelect.options[colorSelect.selectedIndex]?.text || '';
                
                // Get size
                let sizeSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Size"]');
                if (sizeSelect) size = sizeSelect.value || sizeSelect.options[sizeSelect.selectedIndex]?.text || '';
                
                items.push({ color, size, index });
              });
            }
            
            // Fallback for single product (no bundle)
            if (items.length === 0) {
              const productForm = document.getElementById(formId);
              if (productForm) {
                const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
                let color = '';
                let size = '';
                
                // Try to get color/size from variant selects
                const colorRadio = document.querySelector('input[name="Color"]:checked, input[name="Colour"]:checked');
                const sizeRadio = document.querySelector('input[name="Size"]:checked');
                
                if (colorRadio) color = colorRadio.value;
                if (sizeRadio) size = sizeRadio.value;
                
                items.push({ color: color || 'Selected', size: size || '', index: 0 });
              } else {
                items.push({ color: 'Selected', size: '', index: 0 });
              }
            }
            
            return items;
          }
          
          // Populate selection grid with blanket items
          function populateSelectionGrid() {
            if (!selectionGrid) return;
            
            const items = getBundleItemsInfo();
            const monogramPrice = getMonogramUnitPrice();
            
            selectionGrid.innerHTML = '';
            
            items.forEach(function(item, index) {
              const isCompleted = monogramCompletedItems[index] || false;
              const completedClass = isCompleted ? ' is-completed' : '';
              
              const itemHtml = `
                <button type="button" class="monogram-selection-item${completedClass}" data-item-index="${index}">
                  ${isCompleted ? `
                    <div class="monogram-item-remove-badge" data-remove-index="${index}" title="Remove monogram">
                      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                      </svg>
                    </div>
                  ` : ''}
                  <div class="monogram-item-add-icon">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                      <line x1="12" y1="5" x2="12" y2="19"></line>
                      <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                  </div>
                  <div class="monogram-selection-label">
                    Add monogram for <strong>${item.color}</strong>
                    ${item.size ? '<br><small style="color:#666; font-size:11px;">' + item.size + '</small>' : ''}
                  </div>
                  <div class="monogram-selection-price">+${formatMoney(monogramPrice)}</div>
                </button>
              `;
              selectionGrid.insertAdjacentHTML('beforeend', itemHtml);
            });
            
            // Add click handlers to selection items
            selectionGrid.querySelectorAll('.monogram-selection-item').forEach(function(btn) {
              btn.addEventListener('click', function(e) {
                // If clicked on remove badge, handle that separately
                if (e.target.closest('.monogram-item-remove-badge')) {
                  e.preventDefault();
                  e.stopPropagation();
                  const removeIndex = parseInt(e.target.closest('.monogram-item-remove-badge').getAttribute('data-remove-index'));
                  removeMonogramDirectly(removeIndex);
                  return;
                }

                const itemIndex = parseInt(btn.getAttribute('data-item-index'));
                openDetailModal(itemIndex);
              });
            });

            // Update the Done button in selection footer
            updateSelectionDoneButton();
          }

          // Update Selection Done Button visibility and text
          function updateSelectionDoneButton() {
            if (!selectionDoneBtn) return;
            const doneFooter = wrapper.querySelector('.monogram-selection-footer');
            if (!doneFooter) return;

            const completedCount = Object.values(monogramCompletedItems).filter(Boolean).length;
            const totalDisplay = document.querySelector('#monogram-selection-total-{{ section.id }}');
            const totalValue = totalDisplay ? totalDisplay.querySelector('.monogram-selection-total-value') : null;

            if (completedCount > 0) {
              const monogramPrice = getMonogramUnitPrice();
              const totalPrice = monogramPrice * completedCount;
              
              if (totalValue) {
                totalValue.textContent = formatMoney(totalPrice);
              }
              
              doneFooter.style.display = 'flex';
              
              // Validate checkbox
              const checkboxChecked = checkboxTerms && checkboxTerms.checked;
              selectionDoneBtn.disabled = !checkboxChecked;
              
              if (selectionDoneBtn.disabled) {
                selectionDoneBtn.style.opacity = '0.5';
              } else {
                selectionDoneBtn.style.opacity = '1';
              }
            } else {
              doneFooter.style.display = 'none';
            }
          }
          
          // Open selection modal (Step 2)
          function openSelectionModal() {
            if (!selectionOverlay) return;
            
            // Generate monogram items data if not already done
            currentBundleItemCount = getSelectedBundleItemCount();
            if (monogramItemsData.length !== currentBundleItemCount) {
              generateMonogramItems(currentBundleItemCount);
            }
            
            populateSelectionGrid();
            selectionOverlay.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            isMonogramBoxOpen = true;
          }
          
          // Close selection modal
          function closeSelectionModal() {
            if (!selectionOverlay) return;
            selectionOverlay.style.display = 'none';
            document.body.style.overflow = '';
            
            // Update trigger button state
            updateTriggerButtonState();
          }
          
          // Open detail modal (Step 3)
          function openDetailModal(itemIndex) {
            if (!detailOverlay || !detailContent) return;
            
            currentEditingIndex = itemIndex;
            const items = getBundleItemsInfo();
            const itemInfo = items[itemIndex] || { color: 'Blanket', size: '' };
            
            // Get monogram item data
            const itemData = monogramItemsData[itemIndex];
            if (!itemData) {
              console.error('[Monogram] No monogram item data for index:', itemIndex);
              return;
            }
            
            // Get existing preview text and position
            const existingPreviewText = itemData.textInput ? itemData.textInput.value : '';
            const existingFont = itemData.styleSelect ? itemData.styleSelect.value : '';
            const existingColor = itemData.colorSelect ? itemData.colorSelect.value : '';
            const position = itemData.position || { x: 50, y: 50 };
            
            // Prepare font-family CSS with fallbacks
            const fontFamilyCSS = existingFont ? "'" + existingFont + "', cursive, serif" : 'inherit';
            
            // Clone the form elements from the template
            const formHtml = `
              <div class="monogram-detail-image-wrap">
                <div class="monogram-detail-image-container" data-item-index="${itemIndex}">
                  ${itemData.imageContainer ? itemData.imageContainer.innerHTML : ''}
                </div>
              </div>
              <div class="monogram-detail-form">
                <h4 class="monogram-detail-title">MONOGRAM ${itemIndex + 1}</h4>
                
                <label class="monogram-label-item">FONT STYLE</label>
                <select class="monogram-style-select" data-item-index="${itemIndex}">
                  <option value="">Choose a style</option>
                  ${getStyleOptions(itemData.styleSelect ? itemData.styleSelect.value : '')}
                </select>
                
                <label class="monogram-label-item">TEXT COLOR</label>
                <select class="monogram-color-select" data-item-index="${itemIndex}">
                  <option value="">Choose a color</option>
                  <option value="Black"${itemData.colorSelect && itemData.colorSelect.value === 'Black' ? ' selected' : ''}>Black</option>
                  <option value="White"${itemData.colorSelect && itemData.colorSelect.value === 'White' ? ' selected' : ''}>White</option>
                </select>
                
                <label class="monogram-label-item">MONOGRAM TEXT</label>
                <input type="text" class="monogram-text-input" data-item-index="${itemIndex}" maxlength="10" placeholder="Enter text (max 10 chars)" value="${itemData.textInput ? itemData.textInput.value : ''}">
              </div>
            `;
            
            detailContent.innerHTML = formHtml;
            
            // Setup event listeners for the form
            setupDetailFormListeners(itemIndex);
            
            // If there's an existing font, make sure it's loaded
            if (existingFont) {
              console.log('[Monogram] Loading saved font:', existingFont);
              loadFont(existingFont, '').then(function() {
                // Force re-apply the font after loading
                updateDetailPreviewText(itemIndex);
              });
            } else {
              // Ensure preview text is initialized with correct styling even if no font
              updateDetailPreviewText(itemIndex);
            }
            
            // Update image based on color
            setTimeout(function() {
              const color = itemInfo.color;
              if (color) {
                updateDetailModalImage(itemIndex, color);
              }
            }, 100);
            
            // Update detail total
            const detailTotalDisplay = document.querySelector('#monogram-detail-total-{{ section.id }}');
            const detailTotalValue = detailTotalDisplay ? detailTotalDisplay.querySelector('.monogram-detail-total-value') : null;
            if (detailTotalValue) {
              detailTotalValue.textContent = formatMoney(getMonogramUnitPrice());
            }

            // Update buttons based on completed state
            const isCompleted = monogramCompletedItems[itemIndex];
            if (saveBtn) {
              saveBtn.textContent = isCompleted ? 'Update Monogram' : 'Save Monogram';
            }
            if (removeBtn) {
              removeBtn.style.display = isCompleted ? 'flex' : 'none';
            }
            
            // Hide selection, show detail
            if (selectionOverlay) selectionOverlay.style.display = 'none';
            detailOverlay.style.display = 'flex';
            
            // Update save button state
            setTimeout(updateSaveButtonState, 50);
          }
          
          // Get style options HTML
          function getStyleOptions(selectedValue) {
            let optionsHtml = '';
            const styleSelect = monogramItemTemplate ? monogramItemTemplate.querySelector('.monogram-style-select') : null;
            if (styleSelect) {
              styleSelect.querySelectorAll('option').forEach(function(opt) {
                if (opt.value) {
                  const selected = opt.value === selectedValue ? ' selected' : '';
                  optionsHtml += `<option value="${opt.value}" data-url="${opt.getAttribute('data-url') || ''}"${selected}>${opt.textContent}</option>`;
                }
              });
            }
            return optionsHtml;
          }
          
          // Setup detail form listeners
          function setupDetailFormListeners(itemIndex) {
            const styleSelect = detailContent.querySelector('.monogram-style-select');
            const colorSelect = detailContent.querySelector('.monogram-color-select');
            const textInput = detailContent.querySelector('.monogram-text-input');
            const previewText = detailContent.querySelector('.monogram-preview-text');
            const imageContainer = detailContent.querySelector('.monogram-detail-image-container');
            
            // Style change
            if (styleSelect) {
              styleSelect.addEventListener('change', function() {
                const fontName = this.value;
                const fontUrl = this.options[this.selectedIndex]?.getAttribute('data-url') || '';
                
                console.log('[Monogram] Style changed to:', fontName, 'URL:', fontUrl || '(using fallback)');
                
                // Update original data
                if (monogramItemsData[itemIndex] && monogramItemsData[itemIndex].styleSelect) {
                  monogramItemsData[itemIndex].styleSelect.value = fontName;
                }
                
                // Always try to load font (function has fallback URLs)
                if (fontName) {
                  loadFont(fontName, fontUrl).then(function() {
                    console.log('[Monogram] Applying font:', fontName);
                    updateDetailPreviewText(itemIndex);
                  });
                } else {
                  updateDetailPreviewText(itemIndex);
                }
              });
            }
            
            // Color change
            if (colorSelect) {
              colorSelect.addEventListener('change', function() {
                if (monogramItemsData[itemIndex] && monogramItemsData[itemIndex].colorSelect) {
                  monogramItemsData[itemIndex].colorSelect.value = this.value;
                }
                updateDetailPreviewText(itemIndex);
              });
            }
            
            // Text input
            if (textInput) {
              textInput.addEventListener('input', function() {
                if (monogramItemsData[itemIndex] && monogramItemsData[itemIndex].textInput) {
                  monogramItemsData[itemIndex].textInput.value = this.value;
                }
                updateDetailPreviewText(itemIndex);
                updateSaveButtonState(); // Update save button based on text entry
              });
            }
            
            // Update preview text
            updateDetailPreviewText(itemIndex);
          }
          
          // Update preview text in detail modal
          function updateDetailPreviewText(itemIndex) {
            const styleSelect = detailContent.querySelector('.monogram-style-select');
            const colorSelect = detailContent.querySelector('.monogram-color-select');
            const textInput = detailContent.querySelector('.monogram-text-input');
            const previewText = detailContent.querySelector('.monogram-preview-text');
            
            if (previewText && textInput) {
              previewText.textContent = textInput.value.toUpperCase();
              
              if (styleSelect && styleSelect.value) {
                const fontFamily = "'" + styleSelect.value + "', cursive, serif";
                previewText.style.fontFamily = fontFamily;
                console.log('[Monogram] Applied font-family:', fontFamily);
              }
              
              if (colorSelect && colorSelect.value) {
                previewText.style.color = colorSelect.value.toLowerCase() === 'white' ? '#fff' : '#000';
              }
              
              const itemData = monogramItemsData[itemIndex];
              if (itemData && itemData.position) {
                previewText.style.left = itemData.position.x + '%';
                previewText.style.top = itemData.position.y + '%';
              }
            }
          }
          
          // Update image in detail modal based on color
          function updateDetailModalImage(itemIndex, color) {
            const imageContainer = detailContent.querySelector('.monogram-detail-image-container');
            if (!imageContainer) return;
            
            const images = imageContainer.querySelectorAll('.monogram-base-image');
            let foundMatch = false;
            
            images.forEach(function(img) {
              const imgColor = img.getAttribute('data-color') || '';
              const colorLower = color.toLowerCase();
              const imgColorLower = imgColor.toLowerCase();
              
              // Match logic
              if (imgColorLower === colorLower || 
                  imgColorLower.includes(colorLower) || 
                  colorLower.includes(imgColorLower)) {
                img.style.display = 'block';
                foundMatch = true;
              } else {
                img.style.display = 'none';
              }
            });
            
            // Fallback: show first image if no match
            if (!foundMatch && images.length > 0) {
              images[0].style.display = 'block';
            }
          }
          
          // Close detail modal
          
          // Close detail modal
          function closeDetailModal() {
            if (!detailOverlay) return;
            detailOverlay.style.display = 'none';
            currentEditingIndex = -1;
          }
          
          // Go back from detail to selection
          function goBackToSelection() {
            closeDetailModal();
            openSelectionModal();
          }
          
          // Save monogram and go back to selection
          function saveMonogramAndGoBack() {
            if (currentEditingIndex < 0) return;
            
            // Check if text is entered
            const textInput = detailContent.querySelector('.monogram-text-input');
            if (!textInput || !textInput.value.trim()) {
              alert('Please enter monogram text before saving.');
              return;
            }
            
            // Mark as completed
            monogramCompletedItems[currentEditingIndex] = true;
            

            
            // Check if all items are now completed
            // Always return to selection screen to allow user to check terms and click "Done"
            goBackToSelection();
          }
          
          // Remove monogram
          function removeMonogram() {
            if (currentEditingIndex < 0) return;
            
            // Mark as incomplete
            monogramCompletedItems[currentEditingIndex] = false;
            
            // Reset data for this index
            if (monogramItemsData[currentEditingIndex]) {
              const data = monogramItemsData[currentEditingIndex];
              if (data.styleSelect) data.styleSelect.value = '';
              if (data.colorSelect) data.colorSelect.value = '';
              if (data.textInput) data.textInput.value = '';
              data.position = { x: 50, y: 50 };
            }
            
            console.log('[Monogram] Monogram removed for index:', currentEditingIndex);
            
            // Return to selection
            goBackToSelection();
          }
          
          // Update save button state
          function updateSaveButtonState() {
            if (!saveBtn) return;
            
            const textInput = detailContent ? detailContent.querySelector('.monogram-text-input') : null;
            const hasText = textInput && textInput.value.trim();
            
            saveBtn.disabled = !hasText;
          }
          
          // Remove monogram directly from selection grid
          function removeMonogramDirectly(index) {
            console.log('[Monogram] removeMonogramDirectly called for index:', index);
            
            // Mark as incomplete
            monogramCompletedItems[index] = false;
            
            // Reset data for this index
            if (monogramItemsData[index]) {
              const data = monogramItemsData[index];
              if (data.styleSelect) data.styleSelect.value = '';
              if (data.colorSelect) data.colorSelect.value = '';
              if (data.textInput) data.textInput.value = '';
              data.position = { x: 50, y: 50 };
            }
            
            // Refresh the grid
            populateSelectionGrid();
            
            // Update trigger button count
            updateTriggerButtonState();
          }

          // Update trigger button to show active monograms count
          function updateTriggerButtonState() {
            if (!toggleBtn) return;
            
            const completedCount = Object.values(monogramCompletedItems).filter(Boolean).length;
            const label = toggleBtn.querySelector('.monogram-trigger-label');
            
            if (completedCount > 0) {
              toggleBtn.classList.add('has-monograms');
              if (label) label.textContent = 'Edit Monogram';
              
              isMonogramBoxOpen = true;
            } else {
              toggleBtn.classList.remove('has-monograms');
              if (label) label.textContent = 'Add Monogram';
              
              isMonogramBoxOpen = false;
            }
            
            updateATCButtonState();
            updateMonogramTotalPrice();
          }

          // Function to remove all monograms
          function removeAllMonograms() {
            console.log('[Monogram] Remove all monograms');
            for (let i = 0; i < monogramItemsData.length; i++) {
              monogramCompletedItems[i] = false;
              if (monogramItemsData[i]) {
                const data = monogramItemsData[i];
                if (data.styleSelect) data.styleSelect.value = '';
                if (data.colorSelect) data.colorSelect.value = '';
                if (data.textInput) data.textInput.value = '';
                data.position = { x: 50, y: 50 };
              }
            }
            updateTriggerButtonState();
            if (selectionOverlay && selectionOverlay.style.display === 'flex') {
              populateSelectionGrid();
            }
          }
          
          // ========== EVENT LISTENERS FOR MODALS ==========
          
          // Trigger button opens selection modal
          if (toggleBtn) {
            toggleBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              console.log('[Monogram] Trigger button clicked - opening selection modal');
              openSelectionModal();
            });
          }
          
          // Close selection modal
          if (selectionCloseBtn) {
            selectionCloseBtn.addEventListener('click', function(e) {
              e.preventDefault();
              closeSelectionModal();
            });
          }
          
          if (selectionDoneBtn) {
            selectionDoneBtn.addEventListener('click', function(e) {
              e.preventDefault();
              closeSelectionModal();
            });
          }
          
          // Close on overlay click (selection)
          if (selectionOverlay) {
            selectionOverlay.addEventListener('click', function(e) {
              if (e.target === selectionOverlay) {
                closeSelectionModal();
              }
            });
          }
          
          // Detail modal back button
          if (detailBackBtn) {
            detailBackBtn.addEventListener('click', function(e) {
              e.preventDefault();
              goBackToSelection();
            });
          }
          
          // Detail modal close button
          if (detailCloseBtn) {
            detailCloseBtn.addEventListener('click', function(e) {
              e.preventDefault();
              closeDetailModal();
              closeSelectionModal();
            });
          }
          
          // Close on overlay click (detail)
          if (detailOverlay) {
            detailOverlay.addEventListener('click', function(e) {
              if (e.target === detailOverlay) {
                closeDetailModal();
                closeSelectionModal();
              }
            });
          }
          
          // Save button
          if (saveBtn) {
            saveBtn.addEventListener('click', function(e) {
              e.preventDefault();
              saveMonogramAndGoBack();
            });
          }
          
          // Remove button
          if (removeBtn) {
            removeBtn.addEventListener('click', function(e) {
              e.preventDefault();
              removeMonogram();
            });
          }

          // Remove all button
          if (removeAllBtn) {
            removeAllBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              removeAllMonograms();
            });
          }
          
          // Checkbox change
          if (checkboxTerms) {
            checkboxTerms.addEventListener('change', function() {
              updateATCButtonState();
              updateSelectionDoneButton(); // Crucial: Update Done button state immediately
              updateSaveButtonState(); // Also update save button in detail modal
            });
          }
          
          // Bundle detection
          function initBundleDetection() {
            // Track previous bundle to detect actual changes
            let previousBundleId = null;
            
            // Function to handle bundle change
            function handleBundleChange() {
              const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
              const currentBundleId = selectedBundle ? selectedBundle.getAttribute('data-deal-id') || selectedBundle.id || 'unknown' : null;
              
              console.log('[Monogram] handleBundleChange called, selected bundle:', currentBundleId, 'previous:', previousBundleId);
              
              // Only process if bundle actually changed
              if (currentBundleId === previousBundleId && currentBundleId !== 'unknown') {
                console.log('[Monogram] Bundle unchanged, skipping');
                return;
              }
              previousBundleId = currentBundleId;
              
              console.log('[Monogram] Bundle changed to:', currentBundleId);
              
              // Wait a bit for DOM to fully update after bundle selection
              setTimeout(function() {
                const itemCount = getSelectedBundleItemCount();
                currentBundleItemCount = itemCount;
                console.log('[Monogram] New bundle has', itemCount, 'monogram items');
                
                if (isMonogramBoxOpen) {
                  // Regenerate monogram items for the new bundle
                  console.log('[Monogram] Regenerating', itemCount, 'monogram items');
                  generateMonogramItems(itemCount);
                  
                  // After regenerating, read colors from the new bundle and update images
                  setTimeout(function() {
                    console.log('[Monogram] Reading colors from newly selected bundle');
                    updateAllMonogramItemsFromBundleColors();
                  }, 200);
                }
              }, 150); // Wait for DOM to update
            }
            
            // Listen for bundle selection changes (switching between different bundle deals)
            document.addEventListener('change', function(e) {
              if (e.target.matches('input[name^="kaching-bundles-deal"]')) {
                console.log('[Monogram] Bundle deal radio changed');
                // Only prevent scroll, let bundle app handle its own updates
                e.stopPropagation();
                setTimeout(handleBundleChange, 100);
              }
              
              // Listen for bundle color dropdown changes
              // Listen to any select changes within kaching bundles variant wrappers
              if (e.target.matches('.kaching-bundles__bar-variant-select') && e.target.closest('.kaching-bundles__bar--selected')) {
                const selectName = e.target.getAttribute('data-name') || '';
                const wrapper = e.target.closest('.kaching-bundles__bar-variant-selector-wrapper');
                console.log('[Monogram] Bundle dropdown changed - name:', selectName, 'value:', e.target.value);
                
                // Determine if this is the color-related dropdown
                // Check multiple conditions: data-name="Color", data-name="Colour", or it's the first select in the wrapper
                let isColorDropdown = false;
                if (selectName.toLowerCase() === 'color' || selectName.toLowerCase() === 'colour') {
                  isColorDropdown = true;
                } else if (wrapper) {
                  // Check if this is the first select (often color is first)
                  const allSelects = wrapper.querySelectorAll('.kaching-bundles__bar-variant-select');
                  isColorDropdown = allSelects[0] === e.target;
                }
                
                if (!isColorDropdown) {
                  console.log('[Monogram] Not a color dropdown (name:', selectName, '), ignoring');
                  return;
                }
                
                // Only prevent scroll if we're actually handling monogram updates
                if (isMonogramBoxOpen && monogramItemsData.length > 0) {
                  // Stop propagation to prevent scroll-to-top, but allow bundle app to handle variant changes
                  e.stopPropagation();
                }
                
                console.log('[Monogram] Color dropdown detected, will update corresponding monogram item');
                
                // Use setTimeout to ensure this runs AFTER any variant change events
                setTimeout(function() {
                  // Find which bundle item this color dropdown belongs to
                  const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
                  if (selectedBundle && isMonogramBoxOpen && monogramItemsData.length > 0) {
                    const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
                    
                    if (wrapper) {
                      // Find the index of this wrapper
                      const itemIndex = Array.from(variantWrappers).indexOf(wrapper);
                      console.log('[Monogram] Color changed for bundle item index:', itemIndex, '- color:', e.target.value);
                      
                      // Update ONLY the corresponding monogram item's image
                      if (itemIndex >= 0 && itemIndex < monogramItemsData.length) {
                        const selectedColor = e.target.value;
                        console.log('[Monogram] Updating ONLY monogram item', itemIndex, 'to show image for color:', selectedColor);
                        updateSingleMonogramItemImage(itemIndex, selectedColor);
                      } else {
                        console.warn('[Monogram] Item index out of range:', itemIndex, 'total items:', monogramItemsData.length);
                      }
                    } else {
                      console.warn('[Monogram] Could not find wrapper for color dropdown');
                    }
                  } else {
                    console.log('[Monogram] Bundle not selected or monogram box not open');
                  }
                }, 100); // Delay to ensure we process after any variant change events
              }
            });
            
            // Also listen for clicks on bundle bars (in case radio change doesn't fire)
            document.addEventListener('click', function(e) {
              const bundleBar = e.target.closest('.kaching-bundles__bar');
              if (bundleBar && !bundleBar.classList.contains('kaching-bundles__bar--selected')) {
                console.log('[Monogram] Bundle bar clicked');
                // Wait for the bundle to become selected
                setTimeout(handleBundleChange, 200);
              }
            });
            
            // Initial bundle detection on page load
            setTimeout(function() {
              currentBundleItemCount = getSelectedBundleItemCount();
              console.log('[Monogram] Initial bundle detection - item count:', currentBundleItemCount);
              if (monogramBox.style.display !== 'none') {
                generateMonogramItems(currentBundleItemCount);
                
                // If bundle is selected, read colors and update images
                if (isBundleSelected()) {
                  setTimeout(function() {
                    console.log('[Monogram] Initial load - reading bundle colors');
                    updateAllMonogramItemsFromBundleColors();
                  }, 150);
                }
              }
            }, 500);
          }
          
          // Store variant images data for all variants (populated from Liquid template)
          // MUST be defined early so it's available when generateMonogramItems is called
          const variantImagesData = {
            {%- for variant in product.variants -%}
              {{ variant.id }}: {
                {%- assign variant_imgs = variant.metafields.custom.variant_monogram_images -%}
                {%- if variant_imgs != blank and variant_imgs.value.size > 0 -%}
                  images: [
                    {%- for img in variant_imgs.value -%}
                      {
                        src: {{ img | image_url: width: 600 | json }},
                        alt: {{ product.title | append: ' - ' | append: variant.title | json }}
                      }{% unless forloop.last %},{% endunless %}
                    {%- endfor -%}
                  ],
                  source: 'variant',
                  variantTitle: {{ variant.title | json }}
                {%- else -%}
                  images: null,
                  source: 'fallback',
                  variantTitle: {{ variant.title | json }}
                {%- endif -%}
              }{% unless forloop.last %},{% endunless %}
            {%- endfor -%}
          };
          
          // Store product-level images data for fallback (populated from Liquid template)
          const productImagesData = {
            {%- assign product_images = product.metafields.custom.monogram_images -%}
            {%- assign monogram_colors = product.metafields.custom.monogram_colors1.value -%}
            {%- if product_images != blank and product_images.value.size > 0 -%}
              images: [
                {%- for img in product_images.value -%}
                  {
                    src: {{ img | image_url: width: 600 | json }},
                    color: {%- assign color_index = forloop.index0 -%}{%- if monogram_colors[color_index] != blank -%}{{ monogram_colors[color_index] | json }}{%- else -%}'default'{%- endif -%},
                    colorIndex: {{ color_index }}
                  }{% unless forloop.last %},{% endunless %}
                {%- endfor -%}
              ],
              colors: [
                {%- if monogram_colors != blank -%}
                  {%- for color in monogram_colors -%}
                    {{ color | json }}{% unless forloop.last %},{% endunless %}
                  {%- endfor -%}
                {%- endif -%}
              ],
              hasImages: true
            {%- else -%}
              images: null,
              colors: [],
              hasImages: false
            {%- endif -%}
          };
          
          console.log('[Monogram] Loaded variant images data for', Object.keys(variantImagesData).length, 'variants');
          console.log('[Monogram] Variants with images:', Object.keys(variantImagesData).filter(function(id) {
            return variantImagesData[id].images && variantImagesData[id].images.length > 0;
          }).map(function(id) {
            return id + ' (' + variantImagesData[id].variantTitle + ')';
          }));
          console.log('[Monogram] Product-level images available:', productImagesData.hasImages, '-', productImagesData.images ? productImagesData.images.length : 0, 'images');
          
          initBundleDetection();
          updateMonogramButton();
          updateMonogramTotalPrice();
          updateATCButtonState();
          
          // Update monogram images when variant changes (VARIANT-LEVEL APPROACH - PRIORITY)
          // NOTE: This function updates ALL monogram items to the same variant's images
          // When a bundle is selected, it redirects to update from bundle colors instead
          function updateMonogramImagesForVariant(variantId) {
            if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
              console.log('[Monogram] Skipping image update - box closed or no items');
              return;
            }
            
            // If a bundle is selected, update from bundle colors instead
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - redirecting to bundle color update');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            const variantIdInt = parseInt(variantId);
            console.log('[Monogram] Updating images for variant ID:', variantIdInt);
            
            const variantData = variantImagesData[variantIdInt];
            
            if (variantData) {
              console.log('[Monogram] Variant data found:', {
                variantId: variantIdInt,
                variantTitle: variantData.variantTitle,
                hasImages: !!(variantData.images && variantData.images.length > 0),
                imageCount: variantData.images ? variantData.images.length : 0,
                source: variantData.source
              });
            } else {
              console.warn('[Monogram] Variant data NOT found for ID:', variantIdInt);
              console.warn('[Monogram] Available variant IDs:', Object.keys(variantImagesData).map(function(id) {
                return id + ' (' + variantImagesData[id].variantTitle + ')';
              }));
              return;
            }
            
            if (variantData && variantData.images && variantData.images.length > 0) {
              console.log('[Monogram] Variant has', variantData.images.length, 'images - using variant-level images');
              
              monogramItemsData.forEach(function(itemData) {
                if (itemData.imageContainer) {
                  const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                  
                  // Remove old images
                  existingImages.forEach(function(img) {
                    img.remove();
                  });
                  
                  // Add new images for this variant
                  variantData.images.forEach(function(imgData, index) {
                    const newImg = document.createElement('img');
                    newImg.className = 'monogram-base-image';
                    newImg.setAttribute('data-variant-id', variantIdInt);
                    newImg.setAttribute('data-image-source', 'variant');
                    newImg.src = imgData.src;
                    newImg.alt = imgData.alt;
                    newImg.loading = 'lazy';
                    newImg.width = 600;
                    newImg.height = 600;
                    newImg.style.display = index === 0 ? 'block' : 'none';
                    
                    const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
                    if (previewText) {
                      itemData.imageContainer.insertBefore(newImg, previewText);
                    } else {
                      itemData.imageContainer.appendChild(newImg);
                    }
                  });
                  
                  console.log('[Monogram] Updated images for monogram item', itemData.index);
                }
              });
              
              console.log('[Monogram] Successfully updated images for variant', variantIdInt);
            } else {
              // Variant has no variant-level images - fallback to product-level images with color matching
              console.log('[Monogram] Variant has no variant-level images, falling back to product-level images');
              
              if (productImagesData.hasImages && productImagesData.images && productImagesData.images.length > 0) {
                console.log('[Monogram] Using product-level images with color matching');
                
                // Get color from variant title or form options
                const variantData = variantImagesData[variantIdInt];
                let selectedColor = null;
                
                if (variantData && variantData.variantTitle) {
                  // Try to extract color from variant title (e.g., "Limited Edition: Wine Red / Full 50x60 in" -> "Wine Red")
                  const variantTitle = variantData.variantTitle;
                  console.log('[Monogram] Extracting color from variant title:', variantTitle);
                  
                  // Extract color from variant title - look for common color patterns
                  const colorMatch = variantTitle.match(/\b(Black|White|Red|Blue|Green|Gold|Silver|Navy|Gray|Grey|Brown|Beige|Pink|Purple|Orange|Yellow|Wine Red|Wine|Cream|Ivory|Tan|Maroon|Burgundy|Teal|Turquoise|Coral|Lavender|Mint|Peach|Salmon|Olive|Khaki)\b/i);
                  if (colorMatch) {
                    selectedColor = colorMatch[1];
                    console.log('[Monogram] Extracted color from variant title:', selectedColor);
                  }
                }
                
                // If no color found in title, try to get from form options
                if (!selectedColor) {
                  const productForm = document.getElementById(formId);
                  if (productForm) {
                    const colorInputs = productForm.querySelectorAll('input[type="radio"][name*="Color"]:checked, select[name*="Color"]');
                    if (colorInputs.length > 0) {
                      selectedColor = colorInputs[0].value || colorInputs[0].options[colorInputs[0].selectedIndex]?.value;
                      console.log('[Monogram] Got color from form options:', selectedColor);
                    }
                  }
                }
                
                // Also check bundle color if bundle is selected
                if (!selectedColor && isBundleSelected()) {
                  selectedColor = getBundleColorForItem(0);
                  console.log('[Monogram] Got color from bundle:', selectedColor);
                }
                
                // Update images with color matching (will show first image if no color found)
                updateMonogramImagesByColor(selectedColor);
              } else {
                console.log('[Monogram] No product-level images available, keeping existing template images');
              }
            }
          }
          
          // Get color from bundle dropdown for a specific item index
          function getBundleColorForItem(itemIndex) {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return null;
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (itemIndex >= variantWrappers.length) return null;
            
            const wrapper = variantWrappers[itemIndex];
            const colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
            if (!colorSelect) {
              // Fallback: try Colour or first select
              const colourSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
              if (colourSelect) return colourSelect.value || null;
              const firstSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
              if (firstSelect) return firstSelect.value || null;
              return null;
            }
            
            return colorSelect.value || null;
          }
          
          // Get variant ID for a specific bundle item index (using same methods as extractBundleVariantIds)
          function getBundleVariantIdForItem(itemIndex) {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) return null;
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            if (itemIndex >= variantWrappers.length) return null;
            
            const wrapper = variantWrappers[itemIndex];
            let variantId = null;
            
            // Method 1: Try data-variant-id attribute on wrapper
            const dataVariantId = wrapper.getAttribute('data-variant-id');
            if (dataVariantId) {
              const testId = parseInt(dataVariantId);
              if (!isNaN(testId) && testId > 0) {
                variantId = testId;
              }
            }
            
            // Method 2: Try hidden input
            if (!variantId) {
              const hiddenInput = wrapper.querySelector('input[type="hidden"]');
              if (hiddenInput && hiddenInput.value) {
                const testId = parseInt(hiddenInput.value);
                if (!isNaN(testId) && testId > 0) {
                  variantId = testId;
                }
              }
            }
            
            // Method 3: Try [name="id"] input
            if (!variantId) {
              const idInput = wrapper.querySelector('[name="id"]');
              if (idInput && idInput.value) {
                const testId = parseInt(idInput.value);
                if (!isNaN(testId) && testId > 0) {
                  variantId = testId;
                }
              }
            }
            
            // Method 4: Try select - check selected option value
            if (!variantId) {
              const variantSelect = wrapper.querySelector('select');
              if (variantSelect) {
                const selectedOption = variantSelect.options[variantSelect.selectedIndex];
                if (selectedOption && selectedOption.value) {
                  const testId = parseInt(selectedOption.value);
                  if (!isNaN(testId) && testId > 0) {
                    variantId = testId;
                  }
                }
                if (!variantId && variantSelect.value) {
                  const testId = parseInt(variantSelect.value);
                  if (!isNaN(testId) && testId > 0) {
                    variantId = testId;
                  }
                }
              }
            }
            
            // Method 5: Try any input with variant/id in name
            if (!variantId) {
              const variantInputs = wrapper.querySelectorAll('input[name*="variant"], input[name*="id"]');
              variantInputs.forEach(function(input) {
                if (!variantId && input.value) {
                  const testId = parseInt(input.value);
                  if (!isNaN(testId) && testId > 1000000) {
                    variantId = testId;
                  }
                }
              });
            }
            
            // Method 6: Scan all inputs for large numbers (variant IDs)
            if (!variantId) {
              const allInputs = wrapper.querySelectorAll('input, select');
              allInputs.forEach(function(input) {
                if (!variantId) {
                  let value = input.value;
                  if (!value && input.tagName === 'SELECT') {
                    const selectedOption = input.options[input.selectedIndex];
                    value = selectedOption ? selectedOption.value : null;
                  }
                  if (!value) {
                    value = input.getAttribute('value');
                  }
                  if (value) {
                    const testId = parseInt(value);
                    if (!isNaN(testId) && testId > 1000000) {
                      variantId = testId;
                    }
                  }
                }
              });
            }
            
            return variantId;
          }
          
          // Get variant color/title for a monogram item
          // For bundles: gets full variant title from bundle item at itemIndex
          // For single products: gets full variant title from selected variant
          function getVariantColorForMonogramItem(itemIndex) {
            let variantTitle = '';
            
            if (isBundleSelected()) {
              // Bundle selected - get variant ID and then full variant title
              const variantId = getBundleVariantIdForItem(itemIndex);
              if (variantId && variantImagesData[variantId] && variantImagesData[variantId].variantTitle) {
                variantTitle = variantImagesData[variantId].variantTitle;
                console.log('[Monogram] Got variant title from bundle item', itemIndex, ':', variantTitle);
              } else {
                // Fallback: try to construct from selected options
                const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
                if (selectedBundle) {
                  const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
                  if (itemIndex < variantWrappers.length) {
                    const wrapper = variantWrappers[itemIndex];
                    const optionSelects = wrapper.querySelectorAll('.kaching-bundles__bar-variant-select');
                    const optionParts = [];
                    optionSelects.forEach(function(select) {
                      if (select.value) {
                        optionParts.push(select.value);
                      }
                    });
                    if (optionParts.length > 0) {
                      variantTitle = optionParts.join(' / ');
                      console.log('[Monogram] Constructed variant title from bundle options:', variantTitle);
                    }
                  }
                }
              }
            } else {
              // Single product - get from selected variant
              const productForm = document.getElementById(formId);
              if (productForm) {
                const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
                if (variantIdInput) {
                  let variantId = null;
                  if (variantIdInput.tagName === 'SELECT') {
                    variantId = variantIdInput.options[variantIdInput.selectedIndex]?.value;
                  } else {
                    variantId = variantIdInput.value;
                  }
                  
                  if (variantId) {
                    const variantIdInt = parseInt(variantId);
                    if (variantImagesData[variantIdInt] && variantImagesData[variantIdInt].variantTitle) {
                      variantTitle = variantImagesData[variantIdInt].variantTitle;
                      console.log('[Monogram] Got variant title from single product:', variantTitle);
                    }
                  }
                }
              }
            }
            
            return {
              color: '', // Not needed anymore
              title: variantTitle,
              displayText: variantTitle || ''
            };
          }
          
          // Extract color name from strings like "Limited Edition: Purple" -> "Purple"
          function extractColorName(colorString) {
            if (!colorString) return '';
            
            const normalized = colorString.trim();
            
            // Common prefixes to remove
            const prefixes = [
              'Limited Edition:',
              'Limited Edition',
              'Special Edition:',
              'Special Edition',
              'Premium:',
              'Premium'
            ];
            
            let colorName = normalized;
            
            // Remove prefixes
            prefixes.forEach(function(prefix) {
              if (colorName.toLowerCase().startsWith(prefix.toLowerCase())) {
                colorName = colorName.substring(prefix.length).trim();
                // Remove leading colon if present
                if (colorName.startsWith(':')) {
                  colorName = colorName.substring(1).trim();
                }
              }
            });
            
            return colorName;
          }
          
          // Update a single monogram item's image based on color (for bundle items)
          function updateSingleMonogramItemImage(itemIndex, selectedColor) {
            if (!productImagesData.hasImages || !productImagesData.images || productImagesData.images.length === 0) {
              console.warn('[Monogram] No product-level images available for color matching');
              return;
            }
            
            if (itemIndex < 0 || itemIndex >= monogramItemsData.length) {
              console.warn('[Monogram] Invalid item index:', itemIndex);
              return;
            }
            
            const itemData = monogramItemsData[itemIndex];
            if (!itemData || !itemData.imageContainer) {
              console.warn('[Monogram] Item data or image container not found for index:', itemIndex);
              return;
            }
            
            console.log('[Monogram] Updating image for item', itemIndex, 'with color:', selectedColor);
            
            // Extract actual color name (e.g., "Limited Edition: Wine Red" -> "Wine Red")
            const extractedColor = selectedColor ? extractColorName(selectedColor) : '';
            const normalizedColor = extractedColor ? extractedColor.toLowerCase() : '';
            const originalColor = selectedColor ? selectedColor.trim().toLowerCase() : '';
            
            // Remove old images
            const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            console.log('[Monogram] Removing', existingImages.length, 'existing images from item', itemIndex);
            existingImages.forEach(function(img) {
              img.remove();
            });
            
            // Verify images were removed
            const remainingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            if (remainingImages.length > 0) {
              console.error('[Monogram] ERROR: Failed to remove all images, remaining:', remainingImages.length);
            }
            
            // Add all product-level images
            let foundMatchingImage = false;
            let matchingImageIndex = -1;
            
            // First pass: find matching image
            for (let index = 0; index < productImagesData.images.length; index++) {
              if (foundMatchingImage) break; // Exit early if match found
              
              const imgData = productImagesData.images[index];
              const imgColor = (imgData.color || '').toLowerCase();
              
              if (selectedColor) {
                // Try multiple matching strategies
                // Strategy 1: Exact match with extracted color
                if (normalizedColor && imgColor === normalizedColor) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 2: Exact match with original color
                if (originalColor && imgColor === originalColor) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 3: Contains match (either direction)
                if (normalizedColor && (imgColor.includes(normalizedColor) || normalizedColor.includes(imgColor))) {
                  foundMatchingImage = true;
                  matchingImageIndex = index;
                  break;
                }
                // Strategy 4: Word-based matching (split color into words and try each)
                if (normalizedColor) {
                  const colorWords = normalizedColor.split(/\s+/);
                  const imgColorWords = imgColor.split(/\s+/);
                  
                  // Check if any word from selected color matches any word from image color
                  for (let i = 0; i < colorWords.length; i++) {
                    for (let j = 0; j < imgColorWords.length; j++) {
                      if (colorWords[i].length > 2 && imgColorWords[j].length > 2 && colorWords[i] === imgColorWords[j]) {
                        foundMatchingImage = true;
                        matchingImageIndex = index;
                        break;
                      }
                    }
                    if (foundMatchingImage) break;
                  }
                  if (foundMatchingImage) break;
                }
              }
            }
            
            // Second pass: create images and set visibility - ONLY show matching image, no fallback
            productImagesData.images.forEach(function(imgData, index) {
              const newImg = document.createElement('img');
              newImg.className = 'monogram-base-image';
              newImg.setAttribute('data-image-source', 'product');
              newImg.setAttribute('data-color', imgData.color || 'default');
              newImg.setAttribute('data-color-index', imgData.colorIndex || index);
              newImg.src = imgData.src;
              newImg.alt = '{{ product.title | escape }} - ' + (imgData.color || 'default');
              newImg.loading = 'lazy';
              newImg.width = 600;
              newImg.height = 600;
              
              // Only show the matching image - no fallback to first image
              const shouldShow = foundMatchingImage && matchingImageIndex === index;
              
              newImg.style.display = shouldShow ? 'block' : 'none';
              
              const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
              if (previewText) {
                itemData.imageContainer.insertBefore(newImg, previewText);
              } else {
                itemData.imageContainer.appendChild(newImg);
              }
            });
            
            // Log results
            const addedImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
            const visibleImages = Array.from(addedImages).filter(function(img) { return img.style.display === 'block'; });
            
            if (selectedColor && !foundMatchingImage && normalizedColor) {
              console.warn('[Monogram] No matching image found for color:', normalizedColor, 'on item', itemIndex);
              console.warn('[Monogram] Available colors:', productImagesData.images.map(function(img) { return img.color; }));
            } else if (foundMatchingImage) {
              console.log('[Monogram] Successfully updated image for item', itemIndex, 'with color:', selectedColor, '- matched index:', matchingImageIndex);
            }
            console.log('[Monogram] Item', itemIndex, '- Total images:', addedImages.length, '- Visible images:', visibleImages.length);
          }
          
          // Update monogram images based on color matching (for product-level images)
          // Update ALL monogram images based on color matching (for product-level images)
          // NOTE: This function updates ALL monogram items to the same color
          // When a bundle is selected, it redirects to update from bundle colors instead
          function updateMonogramImagesByColor(selectedColor) {
            if (!productImagesData.hasImages || !productImagesData.images || productImagesData.images.length === 0) {
              console.warn('[Monogram] No product-level images available for color matching');
              return;
            }
            
            // If a bundle is selected, update from bundle colors instead
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - redirecting to bundle color update');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            console.log('[Monogram] Updating images by color:', selectedColor || '(no color - showing first image)');
            
            // Extract actual color name (e.g., "Limited Edition: Wine Red" -> "Wine Red")
            const extractedColor = selectedColor ? extractColorName(selectedColor) : '';
            const normalizedColor = extractedColor ? extractedColor.toLowerCase() : '';
            const originalColor = selectedColor ? selectedColor.trim().toLowerCase() : '';
            
            monogramItemsData.forEach(function(itemData) {
              if (itemData.imageContainer) {
                // Remove old images
                const existingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                console.log('[Monogram] Removing', existingImages.length, 'existing images from item', itemData.index);
                existingImages.forEach(function(img) {
                  img.remove();
                });
                
                // Verify images were removed
                const remainingImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                if (remainingImages.length > 0) {
                  console.error('[Monogram] ERROR: Failed to remove all images, remaining:', remainingImages.length);
                }
                
                // Add all product-level images
                let foundMatchingImage = false;
                let matchingImageIndex = -1;
                
                // First pass: find matching image
                for (let index = 0; index < productImagesData.images.length; index++) {
                  if (foundMatchingImage) break; // Exit early if match found
                  
                  const imgData = productImagesData.images[index];
                  const imgColor = (imgData.color || '').toLowerCase();
                  
                  if (selectedColor) {
                    // Try multiple matching strategies
                    // Strategy 1: Exact match with extracted color
                    if (normalizedColor && imgColor === normalizedColor) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 2: Exact match with original color
                    if (originalColor && imgColor === originalColor) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 3: Contains match (either direction)
                    if (normalizedColor && (imgColor.includes(normalizedColor) || normalizedColor.includes(imgColor))) {
                      foundMatchingImage = true;
                      matchingImageIndex = index;
                      break;
                    }
                    // Strategy 4: Word-based matching (split color into words and try each)
                    if (normalizedColor) {
                      const colorWords = normalizedColor.split(/\s+/);
                      const imgColorWords = imgColor.split(/\s+/);
                      
                      // Check if any word from selected color matches any word from image color
                      for (let i = 0; i < colorWords.length; i++) {
                        for (let j = 0; j < imgColorWords.length; j++) {
                          if (colorWords[i].length > 2 && imgColorWords[j].length > 2 && colorWords[i] === imgColorWords[j]) {
                            foundMatchingImage = true;
                            matchingImageIndex = index;
                            break;
                          }
                        }
                        if (foundMatchingImage) break;
                      }
                      if (foundMatchingImage) break;
                    }
                  }
                }
                
                // Second pass: create images and set visibility - ONLY show matching image, no fallback
                productImagesData.images.forEach(function(imgData, index) {
                  const newImg = document.createElement('img');
                  newImg.className = 'monogram-base-image';
                  newImg.setAttribute('data-image-source', 'product');
                  newImg.setAttribute('data-color', imgData.color || 'default');
                  newImg.setAttribute('data-color-index', imgData.colorIndex || index);
                  newImg.src = imgData.src;
                  newImg.alt = '{{ product.title | escape }} - ' + (imgData.color || 'default');
                  newImg.loading = 'lazy';
                  newImg.width = 600;
                  newImg.height = 600;
                  
                  // Only show the matching image - no fallback to first image
                  const shouldShow = foundMatchingImage && matchingImageIndex === index;
                  
                  newImg.style.display = shouldShow ? 'block' : 'none';
                  
                  const previewText = itemData.imageContainer.querySelector('.monogram-preview-text-item');
                  if (previewText) {
                    itemData.imageContainer.insertBefore(newImg, previewText);
                  } else {
                    itemData.imageContainer.appendChild(newImg);
                  }
                });
                
                // Log results
                const addedImages = itemData.imageContainer.querySelectorAll('.monogram-base-image');
                const visibleImages = Array.from(addedImages).filter(function(img) { return img.style.display === 'block'; });
                
                if (selectedColor && !foundMatchingImage && normalizedColor) {
                  console.warn('[Monogram] No matching image found for color:', normalizedColor);
                  console.warn('[Monogram] Available colors:', productImagesData.images.map(function(img) { return img.color; }));
                }
                console.log('[Monogram] Item', itemData.index, '- Total images:', addedImages.length, '- Visible images:', visibleImages.length);
              }
            });
            
            console.log('[Monogram] Images updated by color matching');
          }
          
          // Listen for variant changes to update monogram images
          function handleVariantChange() {
            console.log('[Monogram] Variant change detected');
            
            // Only update images if monogram box is open and items exist
            if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
              console.log('[Monogram] Monogram box is closed or no items, will update when box opens');
              return;
            }
            
            // IMPORTANT: If a bundle is selected, read colors from ALL bundle dropdowns
            // and update each monogram item individually
            if (isBundleSelected()) {
              console.log('[Monogram] Bundle is selected - updating each item from bundle colors');
              updateAllMonogramItemsFromBundleColors();
              return;
            }
            
            // No bundle selected - update all items based on selected variant
            const productForm = document.getElementById(formId);
            if (!productForm) {
              console.warn('[Monogram] Product form not found');
              return;
            }
            
            const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
            let currentVariantId = null;
            
            if (variantIdInput) {
              if (variantIdInput.tagName === 'SELECT') {
                currentVariantId = variantIdInput.options[variantIdInput.selectedIndex]?.value;
              } else {
                currentVariantId = variantIdInput.value;
              }
            }
            
            console.log('[Monogram] Current variant ID:', currentVariantId);
            
            if (currentVariantId) {
              console.log('[Monogram] Monogram box is open, updating images for variant');
              updateMonogramImagesForVariant(parseInt(currentVariantId));
            }
          }
          
          // Update ALL monogram items based on current bundle color selections
          function updateAllMonogramItemsFromBundleColors() {
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            if (!selectedBundle) {
              console.warn('[Monogram] No selected bundle found');
              return;
            }
            
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            console.log('[Monogram] Updating all', variantWrappers.length, 'monogram items from bundle colors');
            
            variantWrappers.forEach(function(wrapper, index) {
              if (index < monogramItemsData.length) {
                // Try multiple selectors for color dropdown
                let colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Color"]');
                if (!colorSelect) {
                  colorSelect = wrapper.querySelector('.kaching-bundles__bar-variant-select[data-name="Colour"]');
                }
                if (!colorSelect) {
                  // Fallback: get the first select in the wrapper (often color is first)
                  colorSelect = wrapper.querySelector('select.kaching-bundles__bar-variant-select');
                }
                
                if (colorSelect && colorSelect.value) {
                  console.log('[Monogram] Item', index, '- setting color from bundle:', colorSelect.value);
                  updateSingleMonogramItemImage(index, colorSelect.value);
                } else {
                  console.warn('[Monogram] Item', index, '- no color found in bundle dropdown');
                }
              }
            });
            
            console.log('[Monogram] All monogram items updated from bundle colors');
          }
          
          // Setup variant change listeners
          function setupVariantChangeListeners() {
            console.log('[Monogram] Setting up variant change listeners...');
            
            // Method 1: Listen to theme's variant change event (PUB_SUB_EVENTS)
            if (typeof subscribe !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
              subscribe(PUB_SUB_EVENTS.variantChange, function(event) {
                console.log('[Monogram] Received PUB_SUB_EVENTS.variantChange event:', event);
                
                if (!isMonogramBoxOpen || monogramItemsData.length === 0) {
                  console.log('[Monogram] Monogram box closed or no items');
                  return;
                }
                
                // If bundle is selected, update all items from bundle colors
                if (isBundleSelected()) {
                  console.log('[Monogram] Bundle selected - updating all items from bundle colors');
                  updateAllMonogramItemsFromBundleColors();
                  return;
                }
                
                // No bundle - update from variant
                if (event && event.data && event.data.variant) {
                  const variantId = event.data.variant.id;
                  console.log('[Monogram] Variant changed to:', variantId);
                  updateMonogramImagesForVariant(variantId);
                } else {
                  // Fallback: get variant ID from form
                  handleVariantChange();
                }
              });
              console.log('[Monogram] Subscribed to PUB_SUB_EVENTS.variantChange');
            } else {
              console.warn('[Monogram] PUB_SUB_EVENTS not available');
            }
            
            // Method 2: Listen to variant-selects custom element
            const variantSelects = document.querySelector('variant-selects');
            if (variantSelects) {
              variantSelects.addEventListener('change', function() {
                console.log('[Monogram] variant-selects change event detected');
                setTimeout(handleVariantChange, 150);
              });
              console.log('[Monogram] Listening to variant-selects element');
            }
            
            // Method 3: Listen to product-form element
            const productFormElement = document.getElementById('ProductForm-{{ section.id }}');
            if (productFormElement) {
              productFormElement.addEventListener('variant:change', function(e) {
                console.log('[Monogram] variant:change event detected', e);
                handleVariantChange();
              });
              console.log('[Monogram] Listening to product-form variant:change event');
            }
            
            // Method 4: Listen to direct form changes (variant selector changes)
            const productForm = document.getElementById(formId);
            if (productForm) {
              // Listen to variant input/select changes
              const variantInput = productForm.querySelector('input[name="id"], select[name="id"]');
              if (variantInput) {
                variantInput.addEventListener('change', function() {
                  console.log('[Monogram] Variant input changed directly:', variantInput.value);
                  handleVariantChange();
                });
                console.log('[Monogram] Listening to variant ID input/select');
              }
              
              // Listen to all option changes (radio buttons, selects)
              productForm.addEventListener('change', function(e) {
                // Check if it's a variant option (not monogram-related)
                if (e.target.name && e.target.name !== 'id' && !e.target.name.includes('monogram') && !e.target.closest('.monogram-box')) {
                  // Prevent scroll-to-top behavior when variant options change
                  // Only prevent if it's a variant selector, not a form submission
                  if (e.target.type === 'radio' || e.target.tagName === 'SELECT') {
                    // Save scroll position and restore it after variant change
                    const savedScrollPosition = window.scrollY || window.pageYOffset;
                    e.stopPropagation();
                    
                    // Restore scroll position after variant change processing
                    requestAnimationFrame(function() {
                      requestAnimationFrame(function() {
                        if (Math.abs(window.scrollY - savedScrollPosition) > 10) {
                          window.scrollTo({ top: savedScrollPosition, behavior: 'instant' });
                        }
                      });
                    });
                  }
                  console.log('[Monogram] Product option changed:', e.target.name, e.target.value);
                  // Small delay to let variant ID update
                  setTimeout(function() {
                    handleVariantChange();
                  }, 150);
                }
              });
              
              console.log('[Monogram] Set up direct form change listeners');
            } else {
              console.warn('[Monogram] Product form not found for variant change listeners');
            }
            
            // Method 5: Use MutationObserver to watch for variant ID changes
            const variantIdInput = document.querySelector('input[name="id"], select[name="id"]');
            if (variantIdInput) {
              const variantIdObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                    const target = mutation.target;
                    if (target.name === 'id' || target.matches('input[name="id"], select[name="id"]')) {
                      console.log('[Monogram] Variant ID value attribute changed:', target.value);
                      setTimeout(handleVariantChange, 150);
                    }
                  }
                });
              });
              
              variantIdObserver.observe(variantIdInput, {
                attributes: true,
                attributeFilter: ['value']
              });
              console.log('[Monogram] Set up MutationObserver for variant ID changes');
            }
            
            console.log('[Monogram] Variant change listeners setup complete');
          }
          
          // Setup currency change listeners
          function setupCurrencyChangeListeners() {
            console.log('[Monogram] Setting up currency change listeners...');
            
            // Method 1: Watch for changes to data-monogram-price attribute
            if (wrapper) {
              const priceObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'attributes' && mutation.attributeName === 'data-monogram-price') {
                    console.log('[Monogram] Currency/price changed detected via data attribute');
                    updateMonogramTotalPrice();
                  }
                });
              });
              
              priceObserver.observe(wrapper, {
                attributes: true,
                attributeFilter: ['data-monogram-price']
              });
              console.log('[Monogram] Set up MutationObserver for price attribute changes');
            }
            
            // Method 2: Watch for changes to price elements (currency switcher might update these)
            const priceElements = document.querySelectorAll('[data-price], .price, price-money');
            if (priceElements.length > 0) {
              const priceElementObserver = new MutationObserver(function(mutations) {
                let shouldUpdate = false;
                mutations.forEach(function(mutation) {
                  if (mutation.type === 'childList' || mutation.type === 'characterData') {
                    shouldUpdate = true;
                  }
                  if (mutation.type === 'attributes' && 
                      (mutation.attributeName === 'data-price' || mutation.attributeName === 'data-currency')) {
                    shouldUpdate = true;
                  }
                });
                if (shouldUpdate && isMonogramBoxOpen) {
                  console.log('[Monogram] Price element changed, updating monogram price');
                  // Small delay to ensure currency conversion is complete
                  setTimeout(updateMonogramTotalPrice, 100);
                }
              });
              
              priceElements.forEach(function(element) {
                priceElementObserver.observe(element, {
                  childList: true,
                  subtree: true,
                  characterData: true,
                  attributes: true,
                  attributeFilter: ['data-price', 'data-currency']
                });
              });
              console.log('[Monogram] Set up MutationObserver for price element changes');
            }
            
            // Method 3: Listen for custom currency change events
            document.addEventListener('currency:change', function() {
              console.log('[Monogram] Currency change event detected');
              setTimeout(updateMonogramTotalPrice, 100);
            });
            
            // Method 4: Periodically check if currency format has changed (fallback)
            let lastMoneyFormat = theme.shopSettings && theme.shopSettings.moneyFormat ? theme.shopSettings.moneyFormat : '';
            setInterval(function() {
              if (theme.shopSettings && theme.shopSettings.moneyFormat) {
                const currentMoneyFormat = theme.shopSettings.moneyFormat;
                if (currentMoneyFormat !== lastMoneyFormat) {
                  console.log('[Monogram] Currency format changed detected');
                  lastMoneyFormat = currentMoneyFormat;
                  if (isMonogramBoxOpen) {
                    updateMonogramTotalPrice();
                  }
                }
              }
            }, 1000); // Check every second
            
            console.log('[Monogram] Currency change listeners setup complete');
          }
          
          // Setup variant change listeners
          setupVariantChangeListeners();
          
          // Setup currency change listeners
          setupCurrencyChangeListeners();
          
          // Helper function to extract bundle variant IDs from DOM
          function extractBundleVariantIds() {
            const bundleVariantIds = [];
            const selectedBundle = document.querySelector('.kaching-bundles__bar--selected');
            
            if (!selectedBundle) {
              // Try theme's native bundle-products element
              const bundleProducts = document.querySelector('bundle-products');
              if (bundleProducts) {
                const bundleIdInputs = bundleProducts.querySelectorAll('[name="id"]');
                bundleIdInputs.forEach(function(input) {
                  const variantId = parseInt(input.value);
                  if (!isNaN(variantId) && variantId > 0) {
                    bundleVariantIds.push(variantId);
                  }
                });
              }
              return bundleVariantIds;
            }
            
            // Method 1: [name="id"] inputs
            const bundleIdInputs = selectedBundle.querySelectorAll('[name="id"]');
            bundleIdInputs.forEach(function(input) {
              const variantId = parseInt(input.value);
              if (!isNaN(variantId) && variantId > 0) {
                bundleVariantIds.push(variantId);
              }
            });
            
            // Method 2: Variant selector wrappers
            const variantWrappers = selectedBundle.querySelectorAll('.kaching-bundles__bar-variant-selector-wrapper');
            variantWrappers.forEach(function(wrapper) {
              let foundVariantId = null;
              
              // Try data-variant-id attribute
              const dataVariantId = wrapper.getAttribute('data-variant-id');
              if (dataVariantId) {
                const variantId = parseInt(dataVariantId);
                if (!isNaN(variantId) && variantId > 0) {
                  foundVariantId = variantId;
                }
              }
              
              // Try hidden input
              if (!foundVariantId) {
                const hiddenInput = wrapper.querySelector('input[type="hidden"]');
                if (hiddenInput && hiddenInput.value) {
                  const variantId = parseInt(hiddenInput.value);
                  if (!isNaN(variantId) && variantId > 0) {
                    foundVariantId = variantId;
                  }
                }
              }
              
              // Try select - check selected option
              if (!foundVariantId) {
                const variantSelect = wrapper.querySelector('select');
                if (variantSelect) {
                  const selectedOption = variantSelect.options[variantSelect.selectedIndex];
                  if (selectedOption && selectedOption.value) {
                    const variantId = parseInt(selectedOption.value);
                    if (!isNaN(variantId) && variantId > 0) {
                      foundVariantId = variantId;
                    }
                  }
                  if (!foundVariantId && variantSelect.value) {
                    const variantId = parseInt(variantSelect.value);
                    if (!isNaN(variantId) && variantId > 0) {
                      foundVariantId = variantId;
                    }
                  }
                }
              }
              
              // Try any input with variant/id in name
              if (!foundVariantId) {
                const variantInputs = wrapper.querySelectorAll('input[name*="variant"], input[name*="id"]');
                variantInputs.forEach(function(input) {
                  if (input.value) {
                    const variantId = parseInt(input.value);
                    if (!isNaN(variantId) && variantId > 1000000) {
                      foundVariantId = variantId;
                    }
                  }
                });
              }
              
              if (foundVariantId && bundleVariantIds.indexOf(foundVariantId) === -1) {
                bundleVariantIds.push(foundVariantId);
              }
            });
            
            // Method 3: Scan all inputs for large numbers (variant IDs)
            if (bundleVariantIds.length === 0) {
              const allInputs = selectedBundle.querySelectorAll('input, select');
              allInputs.forEach(function(input) {
                let value = input.value;
                if (!value && input.tagName === 'SELECT') {
                  const selectedOption = input.options[input.selectedIndex];
                  value = selectedOption ? selectedOption.value : null;
                }
                if (!value) {
                  value = input.getAttribute('value');
                }
                if (value) {
                  const variantId = parseInt(value);
                  if (!isNaN(variantId) && variantId > 1000000 && bundleVariantIds.indexOf(variantId) === -1) {
                    bundleVariantIds.push(variantId);
                  }
                }
              });
            }
            
            return bundleVariantIds;
          }
          
          // Intercept form submission
          const productForm = document.getElementById(formId);
          if (productForm) {
            // Function to add only monogram items to cart (used when bundle app handles bundle items separately)
            function addMonogramItemsToCart() {
              console.log('[Monogram] addMonogramItemsToCart called (delayed/fallback)');
              
              if (typeof fetchConfig === 'undefined') {
                console.error('[Monogram] fetchConfig is not available.');
                return Promise.resolve();
              }
              
              const miniCart = document.querySelector('mini-cart');
              if (!miniCart) {
                console.error('[Monogram] mini-cart element not found');
                return Promise.resolve();
              }
              
              // Build monogram items array (only completed items from popup flow)
              const monogramItems = [];
              monogramItemsData.forEach(function(itemData, itemIndex) {
                // Only include items that were marked as completed in the popup flow
                if (monogramCompletedItems[itemIndex] && itemData.textInput && itemData.textInput.value.trim()) {
                  let productName = '{{ product.title | escape }}';
                  
                  // Get variant info for this monogram item
                  const variantInfo = getVariantColorForMonogramItem(itemIndex);
                  
                  monogramItems.push({
                    id: parseInt(monogramProductId),
                    quantity: 1,
                    properties: {
                      'Monogram Text': itemData.textInput.value.trim() || '',
                      'Monogram Style': (function(val) {
                        if (val === 'Playfair Display') return 'Classic Serif';
                        if (val === 'Pinyon Script') return 'Elegant Script';
                        return val;
                      })((itemData.styleSelect && itemData.styleSelect.value) || ''),
                      'Monogram Color': (itemData.colorSelect && itemData.colorSelect.value) || '',
                      'Product Name': productName,
                      'Variant': variantInfo.title || variantInfo.displayText || '',
                      '_form_ref': formId,
                      '_monogram': 'true'
                    }
                  });
                }
              });
              
              if (monogramItems.length === 0) {
                console.log('[Monogram] No monogram items to add');
                return Promise.resolve();
              }
              
              console.log('[Monogram] Monogram items to add:', monogramItems);
              
              const sections = miniCart.getSectionsToRender ? miniCart.getSectionsToRender().map((section) => section.id) : [];
              const config = fetchConfig('javascript');
              config.headers['X-Requested-With'] = 'XMLHttpRequest';
              config.headers['Content-Type'] = 'application/json';
              
              const requestBody = {
                items: monogramItems,
                sections: sections,
                sections_url: window.location.pathname
              };
              
              config.body = JSON.stringify(requestBody);
              
              if (typeof miniCart.setActiveElement === 'function') {
                miniCart.setActiveElement(document.activeElement);
              }
              
              return fetch(theme.routes.cart_add_url, config)
                .then(function(response) {
                  console.log('[Monogram] Monogram items response status:', response.status);
                  if (!response.ok) {
                    return response.text().then(function(text) {
                      let errorData;
                      try {
                        errorData = JSON.parse(text);
                      } catch (e) {
                        errorData = { description: text || 'Cart error occurred' };
                      }
                      throw new Error(errorData.description || errorData.message || 'Cart error occurred');
                    });
                  }
                  return response.json();
                })
                .then(function(response) {
                  console.log('[Monogram] Monogram items added:', response);
                  if (response.status) {
                    throw new Error(response.description || response.message || 'Cart error occurred');
                  }
                  
                  // Always fetch cart and sections when adding monogram items after bundle
                  return fetch((window.Shopify && window.Shopify.routes && window.Shopify.routes.root ? window.Shopify.routes.root : '/') + 'cart.js')
                    .then(function(cartResponse) {
                      return cartResponse.json();
                    })
                    .then(function(cartData) {
                      console.log('[Monogram] Cart data after monogram add:', cartData);
                      response.item_count = cartData.item_count || 0;
                      response.items = cartData.items || [];
                      // Re-fetch sections to get correct cart state
                      const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                      return fetch(sectionUrl)
                        .then(function(sectionResponse) {
                          return sectionResponse.json();
                        })
                        .then(function(sectionData) {
                          console.log('[Monogram] Sections fetched:', Object.keys(sectionData || {}));
                          response.sections = sectionData;
                          return response;
                        });
                    });
                })
                .then(function(finalResponse) {
                  console.log('[Monogram] Final response for renderContents:', {
                    item_count: finalResponse.item_count,
                    hasSections: !!finalResponse.sections,
                    sectionKeys: Object.keys(finalResponse.sections || {})
                  });
                  
                  if (miniCart && typeof miniCart.renderContents === 'function') {
                    miniCart.renderContents(finalResponse);
                    console.log('[Monogram] miniCart.renderContents called for monogram items');
                  }
                  
                  if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                    publish(PUB_SUB_EVENTS.cartUpdate, {
                      source: 'monogram-form',
                      cartData: finalResponse,
                      cart: finalResponse,
                      sections: finalResponse.sections || {}
                    });
                    console.log('[Monogram] cartUpdate published for monogram items');
                  }
                })
                .catch(function(error) {
                  console.error('[Monogram] Error adding monogram items:', error);
                  alert('Error adding monogram: ' + (error.message || 'Please try again.'));
                })
                .finally(function() {
                  // Re-enable button after monogram items are added
                  if (atcButton) {
                    atcButton.classList.remove('loading');
                    atcButton.removeAttribute('aria-disabled');
                    const hasDataUnavailable = atcButton.hasAttribute('data-unavailable') && atcButton.getAttribute('data-unavailable') === 'true';
                    if (!hasDataUnavailable) {
                      atcButton.disabled = false;
                    }
                    console.log('[Monogram] Button re-enabled after monogram items added');
                  }
                });
            }
            
            // Intercept form submission to add monogram items in capture phase 
            // to ensure we run before theme Ajax logic and can stop propagation.
            productForm.addEventListener('submit', function(e) {
              console.log('[Monogram] product-form submit event captured (capture phase)');
              
              // Check if any monograms have been added and have text
              const hasMonogramText = monogramItemsData.some(function(item, index) {
                return monogramCompletedItems[index] && item.textInput && item.textInput.value.trim();
              });
              
              if (!isMonogramBoxOpen || !hasMonogramText) {
                console.log('[Monogram] Monogram not active or no text entered - letting theme handle submission');
                return; 
              }
              
              // Terms checkbox validation - ALWAYS block if not checked
              if (checkboxTerms && !checkboxTerms.checked) {
                console.log('[Monogram] Terms not checked, blocking submission');
                e.preventDefault();
                e.stopImmediatePropagation();
                alert('Please confirm that you have double-checked your information and understand that monogram items are not eligible for return or exchange.');
                return;
              }
              
              // Check if bundle is selected and if we can find bundle items in DOM
              const bundleSelected = isBundleSelected();
              let bundleItemsFound = false;
              
              if (bundleSelected) {
                console.log('[Monogram] Bundle is selected, checking for bundle items in DOM...');
                const extractedVariantIds = extractBundleVariantIds();
                bundleItemsFound = extractedVariantIds.length > 0;
                console.log('[Monogram] Bundle items found in DOM:', bundleItemsFound, 'Count:', extractedVariantIds.length);
              }
              
              // CASE 1: Bundle is selected but we can't find its items in DOM.
              // We must let the bundle app/theme handle the main product, then we add monograms after.
              if (bundleSelected && !bundleItemsFound) {
                console.log('[Monogram] Bundle selected but items not found in DOM - letting bundle app handle form submission');
                console.log('[Monogram] Will add monogram items after bundle app completes (1000ms delay)');
                
                // We DON'T call preventDefault or stopImmediatePropagation here.
                // This allows the theme/bundle app listeners to run and add the bundle.
                
                setTimeout(function() {
                  console.log('[Monogram] Delayed monogram add triggered');
                  addMonogramItemsToCart().catch(err => console.error('[Monogram] Delayed add failed:', err));
                }, 1000); 
                return; 
              }
              
              // CASE 2: We have all the info we need (Single product OR Bundle with visible items).
              // We take EXCLUSIVE control to add everything in one go for better UX.
              console.log('[Monogram] Taking full control of submission');
              e.preventDefault();
              e.stopImmediatePropagation();
              
              // Check if fetchConfig is available (theme requirement)
              if (typeof fetchConfig === 'undefined') {
                console.error('[Monogram] fetchConfig is not available. Make sure theme global.js is loaded.');
                alert('There was an error: Theme configuration not loaded. Please refresh the page and try again.');
                return;
              }
              
              // Set loading state
              if (atcButton) {
                atcButton.setAttribute('aria-disabled', true);
                atcButton.classList.add('loading');
                atcButton.disabled = true;
              }
              
              // Determine main product variant ID and quantity
              const variantIdInput = productForm.querySelector('input[name="id"], select[name="id"]');
              const currentVariantId = variantIdInput ? (variantIdInput.value || (variantIdInput.options && variantIdInput.options[variantIdInput.selectedIndex]?.value)) : null;
              const currentVariantIdInt = currentVariantId ? parseInt(currentVariantId) : {{ product.selected_or_first_available_variant.id | default: 0 }};
              
              const quantityInput = productForm.querySelector('input[name="quantity"]');
              const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
              
              console.log('[Monogram] Submission values - Main Variant:', currentVariantIdInt, 'Qty:', quantity, 'Monogram Product:', monogramProductId);
              
              if (!currentVariantIdInt || isNaN(currentVariantIdInt) || !monogramProductId || isNaN(monogramProductId) || currentVariantIdInt <= 0 || monogramProductId <= 0) {
                if (atcButton) {
                  atcButton.classList.remove('loading');
                  atcButton.removeAttribute('aria-disabled');
                  atcButton.disabled = false;
                }
                alert('There was an error: Invalid product variant. Please refresh the page and try again.');
                return;
              }
              
              // bundleSelected is already declared above, reuse it
              const items = [];
              
              if (!bundleSelected) {
                // No bundle selected - add main product
                items.push({
                  id: parseInt(currentVariantIdInt),
                  quantity: parseInt(quantity) || 1
                });
                console.log('[Monogram] Adding main product to cart (no bundle selected)');
              } else {
                // Bundle is selected - add bundle items instead of main product
                console.log('[Monogram] Bundle is selected - extracting bundle items');
                
                // Use the helper function to extract bundle variant IDs
                const bundleVariantIds = extractBundleVariantIds();
                console.log('[Monogram] Extracted', bundleVariantIds.length, 'bundle variant IDs:', bundleVariantIds);
                
                // Add found bundle items to cart
                if (bundleVariantIds.length > 0) {
                  bundleVariantIds.forEach(function(variantId) {
                    items.push({
                      id: variantId,
                      quantity: 1
                    });
                    console.log('[Monogram] Adding bundle item to cart:', variantId);
                  });
                  console.log('[Monogram] Added', bundleVariantIds.length, 'bundle items to cart');
                } else {
                  console.warn('[Monogram] Bundle selected but no bundle items found in DOM.');
                  console.warn('[Monogram] Adding main product as fallback since bundle items not detected.');
                  
                  // If we can't find bundle items, add the main product as fallback
                  // This ensures something gets added even if bundle detection fails
                  items.push({
                    id: parseInt(currentVariantIdInt),
                    quantity: parseInt(quantity) || 1
                  });
                  console.log('[Monogram] Added main product as fallback (bundle items not found):', currentVariantIdInt);
                }
              }
              
              // Add monogram items (only completed items from popup flow)
              monogramItemsData.forEach(function(itemData, itemIndex) {
                // Only include items that were marked as completed in the popup flow
                if (monogramCompletedItems[itemIndex] && itemData.textInput && itemData.textInput.value.trim()) {
                  let productName = '{{ product.title | escape }}';
                  
                  // Get variant info for this monogram item
                  const variantInfo = getVariantColorForMonogramItem(itemIndex);
                  
                  const monogramItem = {
                    id: parseInt(monogramProductId),
                    quantity: 1,
                    properties: {
                      'Monogram Text': itemData.textInput.value.trim() || '',
                      'Monogram Style': (function(val) {
                        if (val === 'Playfair Display') return 'Classic Serif';
                        if (val === 'Pinyon Script') return 'Elegant Script';
                        return val;
                      })((itemData.styleSelect && itemData.styleSelect.value) || ''),
                      'Monogram Color': (itemData.colorSelect && itemData.colorSelect.value) || '',
                      'Product Name': productName,
                      'Variant': variantInfo.title || variantInfo.displayText || '',
                      '_form_ref': formId,
                      '_monogram': 'true'
                    }
                  };
                  items.push(monogramItem);
                }
              });
              
              // Add to cart using theme's native method
              console.log('[Monogram] Starting cart add process');
              console.log('[Monogram] Items to add:', items);
              
              const miniCart = document.querySelector('mini-cart');
              if (!miniCart) {
                console.error('[Monogram] mini-cart element not found');
                if (atcButton) {
                  atcButton.classList.remove('loading');
                  atcButton.removeAttribute('aria-disabled');
                  atcButton.disabled = false;
                }
                alert('Cart system not available. Please refresh the page.');
                return;
              }
              
              const sections = miniCart.getSectionsToRender ? miniCart.getSectionsToRender().map((section) => section.id) : [];
              console.log('[Monogram] Sections to render:', sections);
              
              const config = fetchConfig('javascript');
              config.headers['X-Requested-With'] = 'XMLHttpRequest';
              config.headers['Content-Type'] = 'application/json';
              
              const requestBody = {
                items: items,
                sections: sections,
                sections_url: window.location.pathname
              };
              
              console.log('[Monogram] Request body:', requestBody);
              console.log('[Monogram] Cart add URL:', theme.routes.cart_add_url);
              
              config.body = JSON.stringify(requestBody);
              
              // Set active element for cart drawer
              if (typeof miniCart.setActiveElement === 'function') {
                miniCart.setActiveElement(document.activeElement);
              }
              
              fetch(theme.routes.cart_add_url, config)
                .then(function(response) {
                  console.log('[Monogram] Response received:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    headers: Object.fromEntries(response.headers.entries())
                  });
                  
                  // Check response status
                  if (!response.ok) {
                    return response.text().then(function(text) {
                      console.error('[Monogram] Response not OK. Status:', response.status, 'Text:', text);
                      let errorData;
                      try {
                        errorData = JSON.parse(text);
                      } catch (e) {
                        errorData = { description: text || 'Cart error occurred', status: response.status };
                      }
                      throw new Error(errorData.description || errorData.message || 'Cart error occurred');
                    });
                  }
                  
                  // Clone response for error handling
                  const responseClone = response.clone();
                  
                  // Try to parse as JSON
                  return response.json().catch(function(parseError) {
                    console.error('[Monogram] JSON parse error:', parseError);
                    // If JSON parsing fails, try to get text and parse manually
                    return responseClone.text().then(function(text) {
                      console.error('[Monogram] Response text:', text);
                      if (!text || text.trim() === '') {
                        throw new Error('Empty response from server. Please try again.');
                      }
                      try {
                        const parsed = JSON.parse(text);
                        console.log('[Monogram] Manually parsed JSON:', parsed);
                        return parsed;
                      } catch (e) {
                        console.error('[Monogram] Failed to parse response text as JSON:', e);
                        throw new Error('Invalid server response. Please refresh the page and try again.');
                      }
                    });
                  });
                })
                .then(function(response) {
                  console.log('[Monogram] Parsed response:', response);
                  console.log('[Monogram] Response keys:', Object.keys(response || {}));
                  console.log('[Monogram] Response.item_count:', response ? response.item_count : 'undefined');
                  console.log('[Monogram] Response.sections:', response ? response.sections : 'undefined');
                  
                  // Validate response structure
                  if (!response) {
                    console.error('[Monogram] Response is null or undefined');
                    throw new Error('Invalid response from server');
                  }
                  
                  if (response.status) {
                    // Error response
                    console.error('[Monogram] Error response:', response);
                    if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                      publish(PUB_SUB_EVENTS.cartError, {
                        source: 'monogram-form',
                        errors: response.errors || response.description,
                        message: response.message,
                      });
                    }
                    throw new Error(response.description || response.message || 'Cart error occurred');
                  }
                  
                  // Helper function to ensure response has all required properties
                  function ensureResponseStructure(response) {
                    return new Promise(function(resolve) {
                      // Always fetch actual cart count when bundle is selected (bundle items may have been added separately)
                      // Or if item_count is missing from response
                      const needsCartFetch = bundleSelected || response.item_count === undefined;
                      
                      if (needsCartFetch) {
                        // Fetch cart to get actual item_count (includes bundle items if they were added separately)
                        console.log('[Monogram] Fetching cart.js to get actual item_count (bundle selected or item_count missing)');
                        fetch((window.Shopify && window.Shopify.routes && window.Shopify.routes.root ? window.Shopify.routes.root : '/') + 'cart.js')
                          .then(function(cartResponse) {
                            return cartResponse.json();
                          })
                          .then(function(cartData) {
                            console.log('[Monogram] Cart data fetched:', cartData);
                            response.item_count = cartData.item_count || 0;
                            if (!response.items) {
                              response.items = cartData.items || [];
                            }
                            // When bundle is selected, sections in response may be outdated (only show monogram items)
                            // Re-fetch sections to get the correct cart state (with bundle items included)
                            if (bundleSelected && sections.length > 0) {
                              console.log('[Monogram] Bundle selected - re-fetching sections to reflect actual cart state');
                              const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                              return fetch(sectionUrl)
                                .then(function(sectionResponse) {
                                  if (!sectionResponse.ok) {
                                    throw new Error('Failed to fetch sections');
                                  }
                                  return sectionResponse.json();
                                })
                                .then(function(sectionData) {
                                  console.log('[Monogram] Sections re-fetched for bundle:', Object.keys(sectionData || {}));
                                  response.sections = sectionData;
                                  checkSections();
                                })
                                .catch(function(sectionError) {
                                  console.error('[Monogram] Failed to re-fetch sections:', sectionError);
                                  // Use existing sections as fallback
                                  checkSections();
                                });
                            } else {
                              // Continue to sections check
                              checkSections();
                            }
                          })
                          .catch(function(cartError) {
                            console.error('[Monogram] Failed to fetch cart:', cartError);
                            // Fallback: calculate from response items if available
                            if (response.items && Array.isArray(response.items)) {
                              response.item_count = response.items.reduce(function(total, item) {
                                return total + (parseInt(item.quantity) || 0);
                              }, 0);
                              console.log('[Monogram] Calculated item_count from items array as fallback:', response.item_count);
                            } else {
                              response.item_count = 0;
                              response.items = [];
                            }
                            checkSections();
                          });
                        return; // Exit early, will resolve in promise
                      }
                      
                      // If item_count exists, calculate from items if needed
                      if (response.item_count === undefined && response.items && Array.isArray(response.items)) {
                        response.item_count = response.items.reduce(function(total, item) {
                          return total + (parseInt(item.quantity) || 0);
                        }, 0);
                        console.log('[Monogram] Calculated item_count from items array:', response.item_count);
                      }
                      
                      // Helper function to check sections and resolve
                      function checkSections() {
                        // Then, ensure sections exist
                        if (!response.sections && sections.length > 0) {
                          console.log('[Monogram] Fetching sections:', sections);
                          const sectionUrl = window.location.pathname + '?sections=' + sections.join(',');
                          fetch(sectionUrl)
                            .then(function(sectionResponse) {
                              if (!sectionResponse.ok) {
                                throw new Error('Failed to fetch sections');
                              }
                              return sectionResponse.json();
                            })
                            .then(function(sectionData) {
                              console.log('[Monogram] Sections fetched:', Object.keys(sectionData || {}));
                              response.sections = sectionData;
                              resolve(response);
                            })
                            .catch(function(sectionError) {
                              console.error('[Monogram] Failed to fetch sections:', sectionError);
                              // Continue without sections
                              response.sections = {};
                              resolve(response);
                            });
                        } else {
                          // Sections already exist or not needed
                          resolve(response);
                        }
                      }
                      
                      // If we didn't need to fetch cart, check sections now
                      if (!needsCartFetch) {
                        checkSections();
                      }
                    });
                  }
                  
                  // Ensure response structure before proceeding
                  return ensureResponseStructure(response).then(function(finalResponse) {
                    console.log('[Monogram] Final response structure:', {
                      item_count: finalResponse.item_count,
                      hasSections: !!finalResponse.sections,
                      sectionKeys: finalResponse.sections ? Object.keys(finalResponse.sections) : [],
                      hasItems: !!finalResponse.items,
                      itemsLength: finalResponse.items ? finalResponse.items.length : 0
                    });
                    
                    // Validate that we have sections before calling renderContents
                    if (!finalResponse.sections || Object.keys(finalResponse.sections).length === 0) {
                      console.error('[Monogram] No sections available, cannot render cart');
                      throw new Error('Failed to load cart sections. Please refresh the page and try again.');
                    }
                    
                    // Success - update cart using theme's native method
                    console.log('[Monogram] Calling miniCart.renderContents');
                    if (typeof miniCart.renderContents === 'function') {
                      try {
                        miniCart.renderContents(finalResponse);
                        console.log('[Monogram] miniCart.renderContents called successfully');
                      } catch (renderError) {
                        console.error('[Monogram] Error in renderContents:', renderError);
                        console.error('[Monogram] Render error stack:', renderError.stack);
                        throw renderError;
                      }
                    } else {
                      console.error('[Monogram] miniCart.renderContents is not a function');
                      throw new Error('Cart render function not available');
                    }
                    
                    // Publish cart update event (match theme's structure)
                    if (typeof publish !== 'undefined' && typeof PUB_SUB_EVENTS !== 'undefined') {
                      console.log('[Monogram] Publishing cart update event');
                      const cartUpdateData = {
                        source: 'monogram-form',
                        cartData: finalResponse, // For price-per-item.js
                        cart: finalResponse,     // For cart.js onCartUpdate
                        sections: finalResponse.sections || {}
                      };
                      console.log('[Monogram] Cart update data structure:', {
                        hasCartData: !!cartUpdateData.cartData,
                        hasCart: !!cartUpdateData.cart,
                        cartItemCount: cartUpdateData.cart ? cartUpdateData.cart.item_count : 'undefined',
                        cartDataItemCount: cartUpdateData.cartData ? cartUpdateData.cartData.item_count : 'undefined'
                      });
                      publish(PUB_SUB_EVENTS.cartUpdate, cartUpdateData);
                    }
                    
                    // Dispatch custom events for compatibility
                    console.log('[Monogram] Dispatching ajaxProduct:added event');
                    document.dispatchEvent(new CustomEvent('ajaxProduct:added', {
                      detail: {
                        product: finalResponse
                      }
                    }));
                    
                    // Remove is-empty class if present
                    if (miniCart && miniCart.classList && miniCart.classList.contains('is-empty')) {
                      miniCart.classList.remove('is-empty');
                      console.log('[Monogram] Removed is-empty class from mini-cart');
                    }
                    
                    console.log('[Monogram] Cart add completed successfully');
                  });
                })
                .catch(function(error) {
                  console.error('[Monogram] ========== CART ADD ERROR ==========');
                  console.error('[Monogram] Error object:', error);
                  console.error('[Monogram] Error message:', error.message);
                  console.error('[Monogram] Error stack:', error.stack);
                  
                  // Show error message
                  const errorMessage = error.message || 'There was an error adding the product to cart. Please try again.';
                  alert('Error: ' + errorMessage);
                  
                  // Dispatch error event
                  document.dispatchEvent(new CustomEvent('ajaxProduct:error', {
                    detail: {
                      errorMessage: errorMessage
                    }
                  }));
                })
                .finally(function() {
                  console.log('[Monogram] Finally block - cleaning up');
                  // Re-enable submit button
                  if (atcButton) {
                    atcButton.classList.remove('loading');
                    atcButton.removeAttribute('aria-disabled');
                    const isUnavailable = atcButton.hasAttribute('data-unavailable') && atcButton.getAttribute('data-unavailable') === 'true';
                    if (!isUnavailable) {
                      atcButton.disabled = false;
                    }
                    console.log('[Monogram] Submit button re-enabled');
                  }
                });
            }, true); // Use capture phase to intercept before product-form.js
          }
        });
      })();
      </script>
    {%- endif -%}
  {%- endif -%}
{%- endif -%}
</div>